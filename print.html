<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OS Labs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom-style.css">
        <link rel="stylesheet" href="theme/css/custom-font.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">首页</a></li><li class="chapter-item expanded "><a href="lab/index.html"><strong aria-hidden="true">1.</strong> 操作系统实验</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lab/01/index.html"><strong aria-hidden="true">1.1.</strong> 实验一: Linux 的初步认识</a></li><li class="chapter-item expanded "><a href="lab/02/index.html"><strong aria-hidden="true">1.2.</strong> 实验二: 进程的初步认识</a></li><li class="chapter-item expanded "><a href="lab/03/index.html"><strong aria-hidden="true">1.3.</strong> 实验三: 经典进程同步问题</a></li><li class="chapter-item expanded "><a href="lab/04/index.html"><strong aria-hidden="true">1.4.</strong> 实验四: 进程通信</a></li><li class="chapter-item expanded "><a href="lab/05/index.html"><strong aria-hidden="true">1.5.</strong> 实验五: 页面置换算法</a></li><li class="chapter-item expanded "><a href="lab/06/index.html"><strong aria-hidden="true">1.6.</strong> 实验六: Socket 网络通信</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="lab-new/index.html"><strong aria-hidden="true">2.</strong> 操作系统课程设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lab-new/01/index.html"><strong aria-hidden="true">2.1.</strong> 实验一: 多线程同步实验</a></li><li class="chapter-item expanded "><a href="lab-new/02/index.html"><strong aria-hidden="true">2.2.</strong> 实验二: 添加内核模块</a></li><li class="chapter-item expanded "><a href="lab-new/03/index.html"><strong aria-hidden="true">2.3.</strong> 实验三: 打印进程树</a></li><li class="chapter-item expanded "><a href="lab-new/04/index.html"><strong aria-hidden="true">2.4.</strong> 实验四: 添加系统调用</a></li><li class="chapter-item expanded "><a href="lab-new/05/index.html"><strong aria-hidden="true">2.5.</strong> 实验五: 虚拟文件系统</a></li><li class="chapter-item expanded "><a href="lab-new/06/index.html"><strong aria-hidden="true">2.6.</strong> 实验六: 块设备驱动程序</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OS Labs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tsagaanbar/os-labs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="首页"><a class="header" href="#首页">首页</a></h1>
<h2 id="导航"><a class="header" href="#导航">导航</a></h2>
<p><a href="./lab/">操作系统实验</a></p>
<p><a href="./lab-new/">操作系统课程设计</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统实验"><a class="header" href="#操作系统实验">操作系统实验</a></h1>
<p>《操作系统》课程是计算机科学与技术专业的主干课。操作系统是现代计算机系统中必不可少的基本系统软件，对计算机系统资源实施管理，是所有其他软件与计算机硬件的唯一接口，所有用户在使用计算机时都要得到操作系统提供的服务。</p>
<p>《操作系统》课程是一门理论和实践相结合的课程。通过《操作系统》实验教学，可以使学生深入地掌握操作系统的基本概念、基本原理，同时运用《操作系统》提供的方法与技巧对实际问题进行算法设计和程序设计，既能实现与课程同步练习、进一步深化理解和灵活掌握教学内容，又能培养学生程序设计及上机调试的能力。这将为学生《计算机体系结构》、《计算机网络》等后继课程的学习以及今后在相关领域的工作打下坚实的基础。</p>
<p>《操作系统》课程含有 18 学时的实验内容，要求学生完成 Linux 的初步认识、进程同步、进程通信、页面调度算法模拟等实验，使学生了解和掌握操作系统的基本原理，掌握常用操作系统的使用和一般的管理方法等内容。通过《操作系统》实践环节，培养学生认真分析问题、解决问题的能力，同时培养学生面对问题勤于思考及团队合作的意识，最终使学生达到理论与实践相结合的目的。</p>
<p>《操作系统》实验教学计划安排 6 个实验项目。由于每个项目都是一个综合训练，仅仅依靠上机三个学时是远远不够的，尤其是实验 6，具有很大的难度，教师可以根据学生的实际情况调整实验内容。这里要求每个同学上实验课前必须做好充分的准备，如问题的分析、数据类型和系统的设计以及程序的编写、初步的调试等等，上机实验课主要是教师和同学们一起讨论和交流，共同解决系统设计和调试中的问题。只有这样才能很好地达到实验教学的目的。</p>
<h2 id="索引"><a class="header" href="#索引">索引</a></h2>
<ul>
<li>
<p><a href="lab/./01/">实验一：Linux 的初步认识</a></p>
<ul>
<li><a href="lab/./01/#1-%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">安装过程</a></li>
<li><a href="lab/./01/#2-%E5%B8%B8%E8%A7%81-bash-%E5%91%BD%E4%BB%A4">常见 bash 命令</a></li>
<li><a href="lab/./01/#3-vi-%E7%BC%96%E8%BE%91%E5%99%A8">vi 编辑器</a></li>
<li><a href="lab/./01/#2-%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84-shell-%E7%A8%8B%E5%BA%8F">编写简单的 Shell 程序</a></li>
<li><a href="lab/./01/#3-%E8%AE%BE%E8%AE%A1-c-%E7%A8%8B%E5%BA%8F">设计 C 程序</a></li>
<li><a href="lab/./01/#4-makefile-%E6%96%87%E4%BB%B6">Makefile 文件</a></li>
<li><a href="lab/./01/#5-%E6%9E%84%E5%BB%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7cmake">构建管理工具：CMake</a></li>
<li><a href="lab/./01/#6-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9A%E6%97%B6%E5%90%AF%E5%8A%A8">程序的定时启动</a></li>
</ul>
</li>
<li>
<p><a href="lab/./02/">实验二: 进程的初步认识</a></p>
</li>
<li>
<p><a href="lab/./03/">实验三: 经典进程同步问题</a></p>
</li>
<li>
<p><a href="lab/./04/">实验四: 进程通信</a></p>
</li>
<li>
<p><a href="lab/./05/">实验五: 页面置换算法</a></p>
</li>
<li>
<p><a href="lab/./06/">实验六: Socket 网络通信</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验一linux-的初步认识"><a class="header" href="#实验一linux-的初步认识">实验一：Linux 的初步认识</a></h1>
<p>实验课时：3学时</p>
<h2 id="一实验目的"><a class="header" href="#一实验目的">一、实验目的</a></h2>
<ol>
<li>了解 Linux 发行版（Ubuntu）的安装过程</li>
<li>掌握基本的 Shell 命令（bash）</li>
<li>了解 vi 编辑器的使用</li>
<li>设计一个 Shell 程序</li>
<li>设计 C 程序，在 Shell 下使用 gcc 编译器编译 C 程序</li>
<li>设计一个 Makefile 文件</li>
</ol>
<h2 id="二实验原理"><a class="header" href="#二实验原理">二、实验原理</a></h2>
<h3 id="1-安装过程"><a class="header" href="#1-安装过程">1. 安装过程</a></h3>
<p>在主机上安装并使用虚拟机软件（如 VMware Workstation、Oracle VirtualBox 等），建立一个虚拟机。</p>
<p>针对 Ubuntu 的配置，可以选择 2 × CPU + 2 GB RAM 以及 20 GB 以上的磁盘空间，或遵循虚拟机软件的默认配置。</p>
<p>接着需要获取安装介质。可以在官方网站获取 Ubuntu 的安装镜像。</p>
<p>将安装介质装载在虚拟机（客户机）上，启动虚拟机。由于虚拟机“物理驱动器”上默认无操作系统，便会从“光盘驱动器”启动。“光盘驱动器”中装载的即为 Ubuntu 的安装镜像。</p>
<p>之后进行简单的配置。在设置用户名时，可以选择简单的用户名和密码组合，以便输入。</p>
<p>首次进入系统后，可以将软件包源配置为易于访问的镜像源。软件包提供方即为软件源，用户可以通过包管理器获得软件源下所提供的软件包。包管理器会在本地存取一份软件源下可用的软件包列表，即软件源缓存。切换软件源后、每次安装或更新软件包前，最好应该执行一次刷新软件源的操作。</p>
<p>可以在 Ubuntu 桌面应用列表中找到“Software &amp; Updates”应用，更改其中的软件源。Ubuntu 官方下载的镜像安装的系统中包含诸多已有的镜像源。比如，我们可以选择“China”下的“<a href="https://mirrors.ustc.edu.cn/">https://mirrors.ustc.edu.cn/</a>”。确认选择后，点击 Close 关闭应用，会提示用户进行刷新软件包缓存。</p>
<p>用户也可按下 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>T</kbd> 组合键，或在应用列表中打开“终端（Terminal）”应用，在 Shell 中以超级用户（Super User）权限执行 <code>apt update</code> 命令<strong>刷新软件源缓存</strong>。</p>
<p>在首次使用前，还建议执行一次<strong>更新软件包</strong>的操作，即 <code>apt upgrade</code>：</p>
<pre><code class="language-console">$ sudo apt upgrade
</code></pre>
<blockquote>
<p>用户默认以普通用户身份登入，需要使用 <code>sudo</code> 来执行需要提权的操作。上述代码块中，行首的 <code>$</code> 表示目前处于普通用户模式，在输入命令时无需输入。</p>
<p>在一次终端会话中首次使用 <code>sudo</code> 时，会要求用户输入自己的密码。需要注意，键入密码不会回显，输入完成后按 <kbd>Enter</kbd> 提交即可。</p>
</blockquote>
<p>更新完成后，可以重启一次客户机中的系统。</p>
<p>接下来安装一些其他开发所需软件包，如 C/C++ 编译器、git、CMake 等。可以通过安装 <code>build-essential</code> 伪包来安装构建所需的诸软件包。</p>
<pre><code class="language-console">$ sudo apt install build-essential git cmake
</code></pre>
<h3 id="2-常见-bash-命令"><a class="header" href="#2-常见-bash-命令">2. 常见 bash 命令</a></h3>
<p>默认情况下，打开终端，其中运行的就是 Shell 程序。Shell 程序可以解析用户的输入，从而执行用户的指令，比如对计算机（系统）进行操作、运行其他程序。</p>
<p>Ubuntu 默认的 Shell 程序为 bash，有如下常见的命令。</p>
<ul>
<li>cd：改变当前目录命令</li>
<li>pwd：显示目前所在目录的指令</li>
<li>ls：列出指定目录的内容</li>
<li>mkdir：建立目录</li>
<li>cp：文件复制命令</li>
<li>rm：删除文件或目录</li>
<li>mv：文件移动、重命名</li>
<li>chmod：变更档案属性</li>
<li>df：查看系统的文件系统的空间使用情况</li>
<li>du：查看具体某个文件和目录的磁盘空间的占用情况</li>
<li>clear：清除终端中的输出</li>
<li>whoami：查看当前登录用户名</li>
</ul>
<p>用户可以使用“命令行选项”来控制命令的执行，即，向其传递（pass）命令行参数。</p>
<p>如，可以为 <code>ls</code> 命令添加 <code>-l</code> 参数，使其以列表形式输出目录下的内容；亦可以添加 <code>-a</code> 参数，使其输出目录下所有文件及子目录（包含隐藏文件和目录）。</p>
<p>有时候，我们可以将这种单字母的指令组合在一起，即，<code>ls -l -a</code> 等价于 <code>ls -la</code>。</p>
<p>用户还可自定义别名（alias），来简化命令的输入。比如，Ubuntu 默认启用了 <code>la</code> 和 <code>ll</code> 这两个别名，分别对应着 <code>ls -a</code> 和 <code>ls -la</code>。</p>
<p>有关<strong>管道</strong>、<strong>输出重定向</strong>、<strong>PATH 环境变量</strong>、<strong>任务控制</strong>等详情，另请阅读：</p>
<ul>
<li><a href="https://tsagaanbar.gitee.io/newly-programmer-abc/begin-programming/cli/cli-and-shell.html">命令行与 Shell 程序 - 程序员入门指南</a></li>
<li><a href="https://tsagaanbar.gitee.io/newly-programmer-abc/begin-programming/cli/common-commands.html">一些常用 Shell 命令 - 程序员入门指南</a></li>
<li><a href="https://tsagaanbar.gitee.io/newly-programmer-abc/begin-programming/cli/common-cli-tools.html">一些常用命令行工具 - 程序员入门指南</a></li>
</ul>
<p><code>ls -l</code> 命令输出类似如下：</p>
<pre><code class="language-console">$ ls -l
total 12
drwxr-xr-x 2 henry henry 4096 Jul 18 04:50 clash
drwxr-xr-x 6 henry henry 4096 Oct  3 22:31 cwork
-rw-r--r-- 1 henry henry    0 Oct  7 16:04 hello.txt
-rwxr-xr-x 1 henry henry  925 Apr 24 18:09 proxy.sh
</code></pre>
<figure>
<p><img src="lab/01/./assets/ls-color-output.svg" alt="终端输出文本有色彩高亮显示" title="添加了高亮的终端输出文本示例" /></p>
<figcaption>图 1：终端输出文本有色彩高亮显示</figcaption>
</figure>
<p>可以看到，每行行首有诸如 <code>drwxr-xr-x</code> 这样的字符串，第一个字符表示文件类型，如 <code>d</code> 表示文件为目录、<code>-</code> 表示文件为普通文件、<code>l</code> 表示文件为链接。剩余字符三个一组，分别表示所有者权限、所有者同组用户权限，以及其他用户权限。</p>
<p>可以使用 <code>chmod</code> 命令<strong>修改文件权限</strong>。<code>chmod</code> 命令的常用格式如下：</p>
<pre><code>chmod [OPTION]... MODE[,MODE]... FILE...
</code></pre>
<p>即，按照 <code>MODE</code> 所指定的规则修改某 <code>FILE</code> 的模式位。<code>MODE</code> 的格式为 <code>[ugoa...][[-+=][perms...]]</code>，其中 <code>perms</code> 可以是 <code>rwxXst</code> 之中的字母，如有多个字母，则以逗号 <code>,</code> 间隔。</p>
<p><code>ugoa</code> 的组合表述该次修改所针对的用户：</p>
<ul>
<li><code>u</code>：文件的所有者</li>
<li><code>g</code>：文件所有者所在组中的其他用户</li>
<li><code>o</code>：不在文件所有者所在组中的用户，即除了 <code>u</code> 和 <code>g</code> 之外的用户</li>
<li><code>a</code>：所有用户</li>
</ul>
<p>如果不指定 <code>chmod</code> 所针对的用户，则默认为所有用户。</p>
<p><code>+</code> 运算符表示增加对应的权限，<code>-</code> 运算符表示移除对应的权限，<code>=</code> 将增加对应的权限，而移除其余未指定的权限。</p>
<p><code>rwxX</code> 分别代表：</p>
<ul>
<li><code>r</code>：读（read）权限</li>
<li><code>w</code>：写（write）权限</li>
<li><code>x</code>：可执行（execute）权限，或可检索目录权限</li>
<li><code>X</code>：仅当某用户对该文件拥有 <code>x</code> 权限、或该文件为目录时，才增添 <code>x</code> 权限</li>
</ul>
<p>此外，可以使用 <code>ugo</code> 中的一个字母，来代指：</p>
<ul>
<li><code>u</code>：文件所有者具有的权限</li>
<li><code>g</code>：同组其他用户具有的权限</li>
<li><code>o</code>：非 <code>u</code> 或 <code>g</code> 类用户所具有的权限。</li>
</ul>
<p>数码形式的模式使用 1 - 4 个八进制数码来表示，每个数码由 4、2、1 相加而得。省略的数码将被视作前导 0 来处理。第 2 - 4 位八进制数分别表示 <code>u</code>、<code>g</code>、<code>o</code> 的权限，每个数字由 4、2、1 三个数字相加而得。</p>
<ul>
<li>4, (100)<sub>2</sub>：代表 <code>r</code> 权限</li>
<li>2, (010)<sub>2</sub>：代表 <code>w</code> 权限</li>
<li>1, (001)<sub>2</sub>：代表 <code>x</code> 权限</li>
</ul>
<p>比如，<code>chmod a+x file</code> 就是为所有用户添加 <code>file</code> 的可执行权限，其等价于 <code>chmod +111 file</code>。</p>
<p>或者，要修改一个文件为“当前用户 <code>rwx</code> 权限”“其他用户仅拥有 <code>rx</code> 权限”，则可以使用 <code>chmow 755 file</code>。</p>
<blockquote>
<p>可以使用 <code>man chmod</code> 查看关于 <code>chmod</code> 命令的详细说明。</p>
</blockquote>
<p>可以使用 <code>useradd</code> 命令<strong>创建用户</strong>。直接键入 <code>useradd</code> 命令，或者添加 <code>-h</code> 选项，可以看到相关帮助信息。</p>
<p>使用 <code>-m</code> 参数，会为用户在 <code>/home/</code> 目录下创建与用户名同名的用户目录。</p>
<p>假设新建的用户名为 <code>john</code>：</p>
<pre><code class="language-console">$ sudo adduser john -m
</code></pre>
<p>创建用户成功后，新的用户名会写入在 <code>/etc/passwd</code> 文件中，可以通过 <code>cat</code> 或者 <code>grep</code> 命令检验：</p>
<pre><code class="language-console">$ grep '^john' /etc/passwd
john:x:1001:1001::/home/john:/bin/sh
</code></pre>
<p>还可以使用 <code>-G</code> 命令将用户添加到某用户组。如 <code>-G sudo</code> 可以使新建的用户能够使用 <code>sudo</code>，即“拥有管理员权限”。</p>
<pre><code class="language-console">$ sudo useradd -m jason -G sudo
</code></pre>
<p>使用 <code>passwd</code> 命令<strong>修改用户密码</strong>。直接键入 <code>passwd</code> 命令可以修改自己的密码，使用 <code>sudo passwd &lt;username&gt;</code> 修改其他用户的密码。</p>
<pre><code class="language-console">$ sudo passwd jason
</code></pre>
<p>首先需要提供用户当前的密码（如有），之后，要输入两次新密码以确认更改。</p>
<p>可以使用 <code>userdel</code> 命令<strong>删除用户</strong>，附加 <code>-r</code> 参数将同时移除用户的家目录和邮件池。</p>
<pre><code class="language-console">sudo userdel -r john
</code></pre>
<h3 id="3-vi-编辑器"><a class="header" href="#3-vi-编辑器">3. vi 编辑器</a></h3>
<p>基本使用：</p>
<ul>
<li>使用 <code>vi</code> 和某文件名以打开某文件进行编辑，如 <code>vi some.txt</code>；若文件不存在，则将会被创建；</li>
<li>甫一进入程序时为命令模式，按 <code>i</code> 键（键入小写字母 <code>i</code>）进入插入模式，之后的输入将会存入缓存；</li>
<li>按 <kbd>ESC</kbd> 退出插入模式，回到命令模式；</li>
<li>输入以下命令：
<ul>
<li><code>:q</code> 退出程序。如果进行了修改，则无法直接退出；</li>
<li><code>:q!</code> 退出程序并放弃修改；</li>
<li><code>:wq</code> 将改动写入文件并退出。</li>
</ul>
</li>
</ul>
<p>在命令模式下，可以：</p>
<ul>
<li>按 <code>h</code>、<code>l</code> 左右移动光标，按 <code>j</code>、<code>k</code> 上下移动光标</li>
<li>按 <code>x</code> 可以删除字符</li>
<li>按 <code>dd</code> 可以删除当前所在的行</li>
</ul>
<p>要进入插入模式，除了可以按 <code>i</code> 键，还有更多的选择：</p>
<ul>
<li><code>i</code>: 在<strong>光标左侧</strong>输入正文</li>
<li><code>a</code>: 在<strong>光标右侧</strong>输入正文</li>
<li><code>I</code>: 在光标所在行的<strong>行首</strong>输入正文</li>
<li><code>A</code>: 在光标所在行的<strong>行尾</strong>输入正文</li>
<li><code>o</code>: 在光标所在行的下一行增添新行，光标位于新行的行首</li>
<li><code>O</code>: 在光标所在行的上一行增添新行，光标位于新行的行首</li>
</ul>
<blockquote>
<p>事实上，在有图形界面时，可以不必在命令行界面下编辑文本。Ubuntu 自带的 GNOME 桌面提供有 <code>gedit</code> 工具，使用方法类似，即在 Shell 中执行 <code>gedit &lt;filename&gt;</code>，即可打开一个<strong>图形化的编辑界面</strong>。亦可安装自己喜欢的编辑器，如 <a href="https://code.visualstudio.com">Visual Studio Code</a>。</p>
</blockquote>
<h2 id="三实验过程"><a class="header" href="#三实验过程">三、实验过程</a></h2>
<h3 id="1-熟悉常用的-bash-命令"><a class="header" href="#1-熟悉常用的-bash-命令">1. 熟悉常用的 bash 命令</a></h3>
<h3 id="2-编写简单的-shell-程序"><a class="header" href="#2-编写简单的-shell-程序">2. 编写简单的 Shell 程序</a></h3>
<p><a href="lab/01/./hello.sh">hello.sh</a></p>
<pre><code class="language-bash">#!/bin/bash
ls
echo &quot;ls 命令显示完毕&quot;
pwd
echo &quot;pwd 命令显示完毕&quot;
echo &quot;Welocme, $LOGNAME! It's now $(date +%T).&quot;
echo &quot;&quot;
echo &quot;c: View month calendar&quot;
echo &quot;e: View a file&quot;
echo &quot;q: Exit&quot;

echo &quot;Input your choice:&quot;
read choice

case $choice in
    c|C) echo &quot;Month:&quot;
        read month
        echo &quot;Year&quot;
        read year
        cal $month $year # 调用 cal 命令打印月历
    ;;
    e|E) echo &quot;Viewing a file. Input file name:&quot;
        read file
        if  [ -f $file ] ;
        then
            more $file
        else
            echo &quot;This file doesn't exist.&quot;
            exit 1
        fi
    ;;
    q|Q)  echo &quot;Bye!&quot;
        exit 0
    ;;
    *) echo &quot;Illegal choice '$choice'.&quot;
        exit 1
    ;;
esac  # end of cases

echo &quot;The end!&quot;
</code></pre>
<p>文件最开始的 <code>#!/bin/bash</code> 称为 Shebang。在计算领域中，Shebang（也称为 Hashbang）是一个由井号和叹号构成的字符序列（<code>#!</code>），其出现在文本文件的第一行的前两个字符。在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。例如，在终端中输入一个 Shebang 内容为 <code>#!/bin/bash</code> 的文件的路径 <code>path/to/script</code>，则相当于使用 <code>/bin/bash</code> 处的可执行程序解释运行 <code>path/to/script</code> 处的脚本，即 <code>/bin/bash path/to/script</code> 命令。</p>
<p>也就是说，得益于这种机制，脚本文件也可以像一个可执行程序一样来使用。不过，在这之前，还需要为脚本添加可执行的权限。有些时候，下载的可执行文件缺失了信息，也需要重新为其添加可执行权限。</p>
<pre><code class="language-console">$ chmod +x ./hello.sh
$ ./hello.sh
</code></pre>
<blockquote>
<p><code>./hello.sh</code> 是 <code>hello.sh</code> 这个脚本文件的路径，即当前目录下的 <code>hello.sh</code>。对于不在 <code>PATH</code> 环境变量的中的路径下面的可执行程序，需要使用路径以指定运行。</p>
</blockquote>
<p>通过下面的脚本，可以以递归的方式遍历目录下的所有文件。</p>
<p><a href="lab/01/./read-dir.sh">read-dir.sh</a></p>
<pre><code class="language-bash">#!/bin/bash

read_dir() # 递归输出目录下的所有文件
{
    for file in `ls $1`         # 遍历指定目录下的所有文件
    do
        if [ -d $1&quot;/&quot;$file ]    # 判断是目录
        then
            read_dir $1&quot;/&quot;$file
        else
            echo $1&quot;/&quot;$file
            # ./a.out  $1&quot;/&quot;$file   # 可自定义可执行程序
        fi
    done
}

read_dir $1
</code></pre>
<p>对这个脚本稍作修改，可以实现拷贝所有文件到另一个路径下。除此之外，也可以使用带 <code>-r</code> 参数的 <code>cp</code> 命令。</p>
<p><a href="lab/01/./copy-dir.sh">copy-dir.sh</a></p>
<pre><code class="language-bash">#!/bin/bash

copy_dir() # 递归拷贝目录下的所有文件
{
    for file in `ls $1`         # 遍历指定目录下的所有文件
    do
        if [ -d $1&quot;/&quot;$file ]    # 判断是目录，则：
        then
            mkdir $2&quot;/&quot;$file    # 1. 在目标目录下创建同名目录
            copy_dir $1&quot;/&quot;$file # 2. 对这个目录执行递归的操作
        else
            # 如果不是目录，则拷贝该文件到对应目录下的同名文件
            cp $1&quot;/&quot;$file $2&quot;/&quot;$file
        fi
    done
}

copy_dir $1 $2
</code></pre>
<h3 id="3-设计-c-程序"><a class="header" href="#3-设计-c-程序">3. 设计 C 程序</a></h3>
<p>不同于 Shell 脚本由 Shell 程序解释执行，使用 C/C++ 编写的程序需要经过<strong>编译</strong>、<strong>链接</strong>之后生成可执行程序，才能运行。</p>
<p>下面是两个简单的 C/C++ 程序：</p>
<p>【C】 <a href="lab/01/./hello.c">hello.c</a></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello!\n&quot;);
    return 0;
}
</code></pre>
<p>【C++】 <a href="lab/01/./hello.cpp">hello.cpp</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; &quot;Hello!\n&quot;;
    return EXIT_SUCCESS;
}
</code></pre>
<p>在编译 C/C++ 程序之前，需要确保安装了 C/C++ 的编译器。可以在终端中输入 <code>c++ --version</code> 尝试，如果存在可用的编辑器，将会输出对应的版本信息。</p>
<blockquote>
<p>如前所说，类似 <code>-v</code> 和 <code>--version</code> 是 GNU 风格的命令行选项风格。而 Windows 下原生的命令行程序一般采用不同的风格，一般来说使用 <code>/</code> 开头的选项，比如 <code>/?</code>。不过，一些 Windows 下的命令也开始兼容类似 GNU 风格的参数，一些从 *nix 迁移到 Windows 的命令行程序也会保留原来的参数风格。</p>
</blockquote>
<p>如果尚未安装 C/C++ 编译器，可以通过包管理器安装。在 Ubuntu 下，可以安装 GNU 的 gcc 编译器。</p>
<p>一般来说，在安装了编译器后，系统会将 <code>cc</code>、<code>c++</code> 命令关联到可以使用的 C 和 C++ 编译器上。当然，也可以显式指明要使用的编译器。</p>
<p>将需要编译的 C/C++ 源文件传递给对应的编译器即可。输出的可执行文件名默认为当前目录下的 <code>a.out</code> 文件。</p>
<p>如果没有错误，执行命令后将不会额外的提示。如果有，可以观察提示的信息，进行相应的修改。</p>
<pre><code class="language-console">$ cc hello.c
$ ls -l
total 28
-rwxr-xr-x 1 henry henry 16696 Oct  9 00:06 a.out
-rw-r--r-- 1 henry henry    60 Oct  9 00:03 hello.c
-rw-r--r-- 1 henry henry    91 Oct  9 00:03 hello.cpp
</code></pre>
<p>可以看到，生成的 <code>a.out</code> 文件具备可执行权限。直接在 Shell 中输入其路径即可执行该程序。</p>
<pre><code class="language-console">$ ./a.out
Hello!
</code></pre>
<figure>
<p><img src="lab/01/./assets/c-compile-and-run.svg" alt="在 bash 中编译 C 语言源代码并运行程序的示意图" title="在 bash 中编译 C 语言源代码并运行程序的示意图" /></p>
<figcaption>图 2：在 bash 中编译 C 语言源代码并运行程序的示意图</figcaption>
</figure>
<p>可以使用带参数的 <code>-o</code> 选项，来指定输出文件的路径及名称。</p>
<pre><code class="language-console">$ cc hello.c -o main
$ ls -l
total 48
-rwxr-xr-x 1 henry henry 16696 Oct  9 00:26 a.out
-rw-r--r-- 1 henry henry    60 Oct  9 00:03 hello.c
-rw-r--r-- 1 henry henry    91 Oct  9 00:03 hello.cpp
-rwxr-xr-x 1 henry henry 16696 Oct  9 00:27 main
</code></pre>
<p>对于 C++ 源文件，需要使用 C++ 编译器，即使用 <code>c++</code> 命令，或显式指定使用 <code>g++</code> 编译器。</p>
<pre><code class="language-console">$ c++ hello.cpp -o hello
$ ./hello
Hello!
</code></pre>
<p>之前提到过，C/C++ 程序源代码需要经过预处理、编译、链接之后才能运行。事实上，在代码中包含了如 <code>&lt;iostream&gt;</code> 等头文件，只能使代码通过编译，但这时的代码还不清楚所使用的函数的具体实现，还需要链接到 C/C++ 的标准库，并且对最后生成的可执行文件进行一定的封装，才能在对应系统上运行。</p>
<p>在上述的命令操作中，编译器默认对传递进的源代码进行了编译、链接的操作，输出的即为最终的可执行程序。我们也可以传递不同的选项，来逐步进行这个流程。</p>
<blockquote>
<p>C 语言编译器默认链接到 C 语言的库。C++ 编译器默认兼容 C 语言的源文件输入。但如果使用 C 编译器处理 C++ 的源代码，就会在链接阶段出现找不到符号的错误：</p>
<pre><code class="language-console">$ cc hello.cpp
/usr/bin/ld: /tmp/ccqnkM7m.o: in function `main':
hello.cpp:(.text+0x12): undefined reference to `std::cout'
... 省略若干输出
collect2: error: ld returned 1 exit status
</code></pre>
</blockquote>
<p>简单来说，可以先编译源代码生成目标文件，之后再链接生成可执行文件。</p>
<p>可以使用 <code>--help</code> 选项，查看 <code>gcc</code> 的帮助信息：</p>
<pre><code class="language-console">$ gcc --help
Usage: gcc [options] file...
Options:
  -pass-exit-codes         Exit with highest error code from a phase.
  --help                   Display this information.
... 省略若干输出
  -E                       Preprocess only; do not compile, assemble or link.
  -S                       Compile only; do not assemble or link.
  -c                       Compile and assemble, but do not link.
  -o &lt;file&gt;                Place the output into &lt;file&gt;.
... 省略若干输出
</code></pre>
<p>可以看到，使用 <code>-E</code> 选项将仅进行预处理；使用 <code>-S</code> 选项仅编译，但不进行汇编和链接；<code>-c</code> 选项将对文件进行编译（compile）和汇编（assemble），但不链接（link）。</p>
<pre><code class="language-console">$ c++ -c hello.cpp
$ ls -l
total 8
-rw-r--r-- 1 henry henry   91 Oct  9 00:03 hello.cpp
-rw-r--r-- 1 henry henry 2736 Oct  9 00:47 hello.o
</code></pre>
<p>使用 <code>-c</code> 选项后，生成了扩展名为 <code>.o</code> 的目标文件（object file）。</p>
<p>将目标文件作为输入，输出可执行程序。</p>
<pre><code class="language-console">$ c++ hello.o -o main
$ ls -l
total 28
-rw-r--r-- 1 henry henry    91 Oct  9 00:03 hello.cpp
-rw-r--r-- 1 henry henry  2736 Oct  9 00:47 hello.o
-rwxr-xr-x 1 henry henry 17168 Oct  9 00:48 main
</code></pre>
<h3 id="4-makefile-文件"><a class="header" href="#4-makefile-文件">4. Makefile 文件</a></h3>
<p>使用多文件编程，可以减少编译时消耗的时间。编译时，每个源代码文件被视作一个编译单位。如果将项目中的代码分别放在若干源文件中，那么，未经修改的代码就不需要重新编译，这样就能够节省编译时间。最后只需要将目标文件重新链接起来，即可生成新的可执行程序。</p>
<p>在一个源文件中，如果需要使用到其他文件中的符号，需要得知关于符号的声明才能通过编译。链接时，则会寻找这些符号的定义。如果没有找到对应符号的定义，则会出现“未解决符号（Unresolved symbols）”或者“未定义引用（Undefined Reference）”的问题。</p>
<p>如果我们将符号的声明和具体实现放在不同的文件里，就可以方便互相之间的使用。我们将存放声明的文件称为头文件（headers）或者包含（include）文件。这样，负责实现头文件中声明的文件、使用这些符号的其他文件，都只需要包含这个头文件，就能够通过编译。</p>
<blockquote>
<p>可以看到，头文件有可能会被多个源代码文件包含。因此，如果在头文件中直接编写了函数的具体定义，就有可能出现“重复定义”的错误。换言之，在链接时，链接器会查找到多个同名符号。如果有需要在头文件中定义符号，可以将其声明为 <code>inline</code>。此外，如果不同编译单元中使用了同名的不同符号，又不希望相互影响，可以将其声明为 <code>static</code>，这样该符号便不会在链接时暴露于外部。</p>
</blockquote>
<blockquote>
<p>存在一个头文件包含了其他头文件的情况，如果某个文件包含了这样的头文件，且同时包含了该头文件所包含的其他头文件，就会造成重复包含的问题。因此，需要保证每个头文件在一个编译单元中仅被包含一次，也就是，需要为头文件添加“头文件保护（Header Guard）”。</p>
</blockquote>
<blockquote>
<p>有时，头文件中的内容十分繁多。由于包含过程只是相当于将头文件整个复制进源代码文件，复杂的头文件也会造成编译时间的大大增加。因此，会有一些技术来减少这部分的编译时间。</p>
</blockquote>
<p>假设我们的多文件程序如下所示：</p>
<p><a href="lab/01/./multi-files/functions.h">functions.h</a></p>
<pre><code class="language-cpp">#ifndef FUNCTIONS_H
#define FUNCTIONS_H

int f(int x);

#endif
</code></pre>
<p><a href="lab/01/./multi-files/functions.c">functions.c</a> </p>
<pre><code class="language-cpp">#include &quot;functions.h&quot;

int f(int x) { return x * 2; }
</code></pre>
<p><a href="lab/01/./multi-files/hello.c">hello.c</a>:</p>
<pre><code class="language-cpp">#include &quot;functions.h&quot;
#include &quot;stdio.h&quot;

int main() {
    printf(&quot;Welcome, Henry.\n&quot;);
    int x1 = 5;
    int x2 = 6;
    int x3 = 7;
    printf(&quot;The result of f(%d) is %d.\n&quot;, x1, f(x1));
    printf(&quot;The result of f(%d) is %d.\n&quot;, x2, f(x2));
    printf(&quot;The result of f(%d) is %d.\n&quot;, x3, f(x3));
    return 0;
}
</code></pre>
<blockquote>
<p><code>hello.c</code> 包含 <code>main</code> 函数。C/C++ 程序默认将从 <code>main</code> 函数执行。即，生成的可执行程序中需要有，且只有一个 <code>main</code> 函数。</p>
</blockquote>
<p>假设将这些文件放在同一个目录下。可以使用 <code>cat</code> 命令将文件内容输出在终端。</p>
<p>要运行以上的多文件程序，我们可以逐个编译源代码文件、得到对应的目标文件，而后将他们链接起来，生成可执行程序。</p>
<pre><code class="language-console">$ cc -c functions.c
$ cc -c hello.c
$ ls -l
total 20
-rw-r--r-- 1 henry henry   47 Oct  9 01:31 functions.c
-rw-r--r-- 1 henry henry   30 Oct  9 01:30 functions.h
-rw-r--r-- 1 henry henry 1368 Oct  9 01:36 functions.o
-rw-r--r-- 1 henry henry  330 Oct  9 01:30 hello.c
-rw-r--r-- 1 henry henry 2112 Oct  9 01:42 hello.o
$ cc functions.o hello.o -o main
$ ./main
Welcome, Henry.
The result of f(5) is 10.
The result of f(6) is 12.
The result of f(7) is 14.
</code></pre>
<p>可以看到，要完成上述的编译、链接操作，我们需要键入 3 条命令。随着文件数目的增多、构建过程的复杂，输入的命令将会越来越多。</p>
<p>不过，我们可以在 <code>make</code> 工具的帮助下进行构建操作。执行 <code>make</code> 命令，会按照目录下的名为 <code>Makefile</code> 的文件执行相应的操作。</p>
<p>对于一个简单工程来说，我们一般希望：</p>
<ol>
<li>如果工程没有编译过，那么所有源代码文件都要编译并被链接；</li>
<li>如果工程的某几个源代码文件被修改，那么只编译被修改的文件，并链接生成目标可执行程序；</li>
<li>如果工程中的头文件被改变了，那么需要重新编译引用了这几个头文件的源代码文件，并链接生成目标可执行程序。</li>
</ol>
<p>只要书写了正确的 Makefile 文件，<code>make</code> 工具可以帮我们实现上述这些功能。</p>
<p>Makefile 由若干规则组成，每个规则描述了以何种方式生成一个目标，以及该目标所需的依赖。格式如下：</p>
<pre><code class="language-makefile">target ... : prerequisites ...
    command
    ...
</code></pre>
<ul>
<li>target：可以是一个目标文件，也可以是一个执行文件，还可以是一个标签（label）；</li>
<li>prerequisites：生成该 target 所依赖的文件和/或其他 target；</li>
<li>command：生成 target 所要执行的命令（任意的 Shell 命令）。</li>
</ul>
<p>可以看到，我们规则描述出文件的依赖关系，也就是说，一个 target 依赖于某些 prerequisites，而 target 生成规则定义在 command 中。假如 prerequisites 中如果有一个以上的文件比 target 文件要新的话，就会重新生成该 target。</p>
<p>有了这些，我们就可以书写使用以上项目的 Makefile 了。</p>
<p><a href="lab/01/./multi-files/Makefile">Makefile</a></p>
<pre><code class="language-makefile">main: hello.o functions.o
	cc -o main hello.o functions.o

hello.o: hello.c functions.h
	cc -c hello.c

functions.o: functions.c functions.h
	cc -c functions.c

clean:
	rm main hello.o functions.o
</code></pre>
<p>需要注意，command 行需要以一个 Tab 为开始。</p>
<p>make 会比较 targets 和 prerequisites 的修改日期，如果 prerequisites 的日期比 targets 文件的日期更新，或者 target 不存在的话，make 就会执行后续定义的命令。</p>
<p>上述 Makefile 中，clean 只是一个动作名字，其冒号后什么也没有，那么 make 就不会自动去找它的依赖项，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 <code>make</code> 命令后显式指出这个 label 的名字。</p>
<p>比如，根据上述的 Makefile 执行 <code>make clean</code>，就会删除掉构建过程中产生的目标文件以及最后生成的可执行文件，还予用户一份清净。</p>
<blockquote>
<p>更多关于 Makefile 的介绍，可以移步 <a href="https://seisman.github.io/how-to-write-makefile/introduction.html">跟我一起写 Makefile（重制版） - 介绍</a>。关于详情可以移步 <a href="https://github.com/seisman/how-to-write-makefile">跟我一起写 Makefile（重制版）在 GitHub 上的仓库</a>。</p>
</blockquote>
<h3 id="5-构建管理工具cmake"><a class="header" href="#5-构建管理工具cmake">5. 构建管理工具：CMake</a></h3>
<p>亦可使用 CMake 这一款构建管理工具。CMake 会生成用于指定构建工具（比如上文中使用的 GNU make）的脚本。通过编写 <code>CMakeLists.txt</code> 文件，可以制定项目的构建方式，并通过 CMake 生成跨平台的构建脚本。</p>
<p>首先，需要安装 CMake 程序，并将 <code>cmake</code> 命令行工具添加入 PATH 环境变量。可以从包管理器安装 CMake，比如 <code>sudo apt install cmake</code>。</p>
<p>之后，编写 <a href="lab/01/./multi-files/CMakeLists.txt">CMakeLists.txt</a>：</p>
<pre><code class="language-cmake"># 要求最低的 CMake 版本
cmake_minimum_required(VERSION 3.1)

# 项目名称
project(hello)

# 生成可执行程序的目标
add_executable(main hello.c functions.h functions.c)
</code></pre>
<p>然后，需要新建一个目录，用来存放构建过程产生的文件。比如，可以在当前文件夹下新建一个 <code>build</code> 目录。将构建目录与源代码分开是个良好的习惯。</p>
<p>进入该目录后，调用 CMake，并将 <code>CMakeLists.txt</code> 所在的目录传递给 <code>cmake</code>。之后，CMake 将进行构建文件的生成。在 Ubuntu 下，默认会生成针对 GNU make 的 Makefile。完成生成后，我们在构建目录下执行 <code>make</code> 即可开始构建。</p>
<pre><code class="language-console">$ mkdir build
$ cd build
$ cmake ..
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/henry/multi-files/build
$ make
Scanning dependencies of target main
[ 33%] Building C object CMakeFiles/main.dir/hello.c.o
[ 66%] Building C object CMakeFiles/main.dir/functions.c.o
[100%] Linking C executable main
[100%] Built target main
$ ./main
Welcome, Henry.
The result of f(5) is 10.
The result of f(6) is 12.
The result of f(7) is 14.
</code></pre>
<p>更多关于 CMake 的介绍：</p>
<ul>
<li><a href="https://llvm.org/docs/CMakePrimer.html">https://llvm.org/docs/CMakePrimer.html</a></li>
</ul>
<h3 id="6-程序的定时启动"><a class="header" href="#6-程序的定时启动">6. 程序的定时启动</a></h3>
<p>Linux 上的 <code>cron</code> 守护进程能够在特定时间运行若干任务。使用正确的语法将任务添加进 <code>crontab</code> 文件即能够使 <code>cron</code> 自动运行这些任务。</p>
<p>计划任务通常为了被用来执行定期备份、系统维护以及其他重复性的操作。</p>
<p>使用 <code>crontab -e</code> 将开启当前用户的 <code>crontab</code> 文件。该文件中的命令将以当前用户的权限执行。</p>
<p>如果需要以系统权限执行任务，则使用 <code>sudo crontab -e</code> 打开 root 用户的 <code>crontab</code> 文件。</p>
<p>执行命令后，会提示选择一个编辑器，这里可以选择 GNU Nano 或者 vim。GNU nano 比较易于使用；vim 的使用方式类似 vi。</p>
<blockquote>
<p>如果想要修改使用的编辑器，可以退出后，在 bash 中设置一个临时环境变量 <code>EDITOR</code>，比如：</p>
<pre><code class="language-console">$ export EDITOR=vim
</code></pre>
</blockquote>
<p>每行以下面的格式声明一个计划任务：</p>
<pre><code>[minute] [hour] [day of month] [month] [day of week] [command]
</code></pre>
<p>在对应的位置使用 <code>*</code> 以匹配任意值。</p>
<p>比如，下面这个任务将在每天凌晨 0:30 执行：</p>
<pre><code>29 0 * * * /usr/bin/example
</code></pre>
<p>可以使用逗号 <code>,</code> 匹配多个值。下面的这个任务每 15 分钟执行一次。</p>
<pre><code>0,14,29,44 * * * * /usr/bin/example2
</code></pre>
<p>使用连字符 <code>-</code> 指定一个区间。下面的任务每天中午执行，但只限于每年的上半年：</p>
<pre><code>0 11 * 1-6 * /usr/bin/example3
</code></pre>
<blockquote>
<p>根据 GNU Nano 下方的提示，<code>^O</code> 以保存文件，即，按 <kbd>Ctrl</kbd> + <kbd>O</kbd> 保存文件，再按 Enter 确认保存的文件名。使用 <kbd>Ctrl</kbd> + <kbd>X</kbd> 可以退出 Nano。</p>
</blockquote>
<p>保存后，可以看到 <code>crontab: installing new crontab</code> 的信息，这表明成功安装了新的 <code>crontab</code> 文件。</p>
<blockquote>
<p>除此之外，也可以使用 <code>at</code> 程序来实现单次的计划任务。</p>
</blockquote>
<p>参考链接：</p>
<ul>
<li><a href="https://www.howtogeek.com/101288/how-to-schedule-tasks-on-linux-an-introduction-to-crontab-files/">https://www.howtogeek.com/101288/how-to-schedule-tasks-on-linux-an-introduction-to-crontab-files/</a></li>
<li><a href="https://linuxhint.com/schedule_linux_task/">https://linuxhint.com/schedule_linux_task/</a></li>
<li><a href="https://www.simplified.guide/linux/automatically-run-program-on-startup">https://www.simplified.guide/linux/automatically-run-program-on-startup</a></li>
<li><a href="https://askubuntu.com/questions/735935/running-command-at-startup-on-crontab">https://askubuntu.com/questions/735935/running-command-at-startup-on-crontab</a></li>
</ul>
<h2 id="四实验心得"><a class="header" href="#四实验心得">四、实验心得</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验二进程的初步认识"><a class="header" href="#实验二进程的初步认识">实验二：进程的初步认识</a></h1>
<p>实验课时：3 学时</p>
<h2 id="一实验目的-1"><a class="header" href="#一实验目的-1">一、实验目的</a></h2>
<ol>
<li>熟练使用系统调用：<code>fork</code>、<code>getpid</code>、<code>getppid</code>、<code>execvp</code>；</li>
<li>设计程序，实现结果的不可再现性；使用同步原语，实现结果的可再现性；</li>
<li>设计程序，使用递归及非递归方法对系统的进程数目进行压力测试，对运行时间进行监控。</li>
</ol>
<!-- 备注：使用同步原语，实现结果的可再现性：采用wait,semop。备注文字不写入实验报告 -->
<h2 id="二实验原理-1"><a class="header" href="#二实验原理-1">二、实验原理</a></h2>
<h3 id="1-简单的系统调用"><a class="header" href="#1-简单的系统调用">1. 简单的系统调用</a></h3>
<h4 id="fork"><a class="header" href="#fork">fork()</a></h4>
<p><code>fork</code> 是符合 POSIX 要求的系统调用，在大多数类 Unix 系统上都可以使用。它可以用来创建新的进程，这个新的进程称作<strong>子进程</strong>（Child）。相对的，<code>fork</code> 的调用者（Caller）就称为父进程（Parent）。子进程是父进程的一份拷贝，也就是说，两个进程的数据段和代码段是相同的（但是不共享这些存储空间），当前执行的代码位置也是一样的，当子进程创建完成后，两个进程都会执行 <code>fork</code> 之后的代码。</p>
<p>通过 <code>fork</code> 调用，可以实现程序的并发运行，也可以运行文件系统中的其他可执行程序。</p>
<blockquote>
<p>事实上，内核在进行进程的拷贝时，采用的是 Copy-On-Write 的方式，即只在发生写入时才真正进行数据的拷贝。</p>
<ul>
<li><code>fork()</code> 和 <code>CreateProcess()</code> 的区别：<a href="https://stackoverflow.com/questions/13839935/forking-and-createprocess">https://stackoverflow.com/questions/13839935/forking-and-createprocess</a></li>
<li>为什么要通过 fork 来创建新的进程：<a href="https://unix.stackexchange.com/questions/136637/why-do-we-need-to-fork-to-create-new-processes/136649#136649">https://unix.stackexchange.com/questions/136637/why-do-we-need-to-fork-to-create-new-processes/136649#136649</a></li>
</ul>
</blockquote>
<p><code>fork()</code> 不接收参数，而在两个进程中均返回一个值：如果进程创建成功，则在父进程中返回子进程的 PID 值，在子进程中返回 0；否则，在父进程中返回 -1。</p>
<pre><code class="language-cpp">pid_t fork(void);
</code></pre>
<p>示例程序 <a href="lab/02/./fork-demo.cpp">fork-demo.cpp</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

int main() {
    pid_t child_pid = fork();

    if (child_pid == -1) {
        perror(&quot;fork&quot;);
        exit(EXIT_FAILURE);
    } else if (child_pid &gt; 0) {
        std::cout &lt;&lt; &quot;printed from parent process &quot; &lt;&lt; getpid() &lt;&lt; std::endl;
        wait(nullptr);
    } else {
        std::cout &lt;&lt; &quot;printed from child process &quot; &lt;&lt; getpid() &lt;&lt; std::endl;
        exit(EXIT_SUCCESS);
    }

    return EXIT_SUCCESS;
}
</code></pre>
<p>程序的输出类似如下：</p>
<pre><code>printed from parent process 705
printed from child process 706
</code></pre>
<p><img src="lab/02/assets/fork-demo.svg" alt="fork 示例程序的运行结果的终端示意图" /></p>
<p>需要注意，程序每次执行的结果可能都会不一样，并不能保证子进程和父进程执行的先后顺序；此外，每次执行时进程的 PID 也不尽相同。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/create.html">https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/create.html</a></li>
</ul>
<h4 id="wait"><a class="header" href="#wait">wait()</a></h4>
<p>调用了 <code>wait()</code> 的进程将一直被阻塞，直到其中一个子进程退出，或者接收到相应的信号。<code>wait()</code> 接收一个 <code>int</code> 类型变量的地址作为参数，而将返回完成了的子进程的参数。表示子进程的完成状态的标志将写入传入的 <code>int</code> 类型指针所指向的地址。</p>
<p><code>wait()</code> 的执行有两种可能的情况：</p>
<ul>
<li>如果调用 <code>wait()</code> 时，有至少一个子进程正在运行，则调用者将被阻塞直至某一子进程退出，之后，调用者继续执行后续代码。</li>
<li>如果调用 <code>wait()</code> 时没有子进程正在运行，则该次调用不产生影响。</li>
</ul>
<p>考虑下面的程序：</p>
<p><a href="lab/02/./wait-demo.c">wait-demo.c</a></p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

#define MAX_COUNT   100
#define BUF_SIZE    100

void ChildProcess(char[], char[]); /* child process declare */

int main(void)
{
    pid_t     pid1, pid2, pid;
    int       status;
    int       i;
    char      buf[BUF_SIZE];

    printf(&quot;*** Parent is about to fork process 1 ***\n&quot;);

    pid1 = fork();
    if (pid1 &lt; 0) {
        printf(&quot;Failed to fork process 1\n&quot;);
        return 1;
    } else if (pid1 == 0) {  /* In Child Process */
        ChildProcess(&quot;First&quot;, &quot;   &quot;);
        return 0;
    }

    printf(&quot;*** Parent is about to fork process 2 ***\n&quot;);

    pid2 = fork();
    if (pid2 &lt; 0) {
        printf(&quot;Failed to fork process 2\n&quot;);
        return 1;
    } else if (pid2 == 0) {
        ChildProcess(&quot;Second&quot;, &quot;      &quot;);
        return 0;
    }

    /* The parent process can do something else. */

    sprintf(buf, &quot;*** Parent enters waiting status .....\n&quot;);
    write(1, buf, strlen(buf));

    pid = wait(&amp;status);
    sprintf(buf, &quot;*** Parent detects process %d was done ***\n&quot;, pid);
    write(1, buf, strlen(buf));

    pid = wait(&amp;status);
    printf(&quot;*** Parent detects process %d is done ***\n&quot;, pid);

    printf(&quot;*** Parent exits ***\n&quot;);
    return 0;
}

/* Child Process's Code */
void ChildProcess(char *number, char *space)
{
    pid_t pid;
    int i;
    char buf[BUF_SIZE];

    pid = getpid();
    sprintf(buf, &quot;%s%s child process starts (pid = %d)\n&quot;,
           space, number, pid);
    write(1, buf, strlen(buf));

    for (i = 1; i &lt;= MAX_COUNT; i++) {
        sprintf(buf, &quot;%s%s child's output, value = %d\n&quot;, space, number, i);
        write(1, buf, strlen(buf));
    }

    sprintf(buf, &quot;%s%s child (pid = %d) is about to exit\n&quot;,
           space, number, pid);
    write(1, buf, strlen(buf));
}
</code></pre>
<p>程序中通过两次 <code>fork</code> 调用创建了两个子进程，因此需要两次 <code>wait</code> 以等待子进程执行完毕。</p>
<p>需要注意的是，由于两个进程并发执行，我们无从得知某个进程会先于另一个结束运行，因此等待某一个特定的进程完成任务可能会导致“忙等（busy-waiting）”的现象出现。</p>
<ul>
<li><a href="http://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/wait.html">http://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/wait.html</a></li>
</ul>
<h4 id="execvp"><a class="header" href="#execvp">execvp()</a></h4>
<p>创建出的子进程并不一定要和父进程执行相同的代码。诸 <code>exec</code> 系统调用即是用来使一进程得以运行任意的程序文件，包括二进制可执行程序或 shell 脚本。</p>
<p><code>execvp()</code> 调用执行后，由第一个参数（<code>char *</code>）指定的程序文件，将被加载入调用者的地址空间，覆盖掉原有的程序代码；第二个参数指定的参数数组（<code>char **</code>）将被传递给该程序。</p>
<p>如果执行失败，<code>execvp()</code> 将返回一个负值。</p>
<p>我们可以实现一个简单的 shell 程序（或者说，一个能够根据用户从终端输入的字符串启动其他程序的程序）。</p>
<ul>
<li><a href="http://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/exec.html">http://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/exec.html</a></li>
</ul>
<h2 id="三实验内容"><a class="header" href="#三实验内容">三、实验内容</a></h2>
<h3 id="1-进程执行先后顺序的不可再现"><a class="header" href="#1-进程执行先后顺序的不可再现">1. 进程执行先后顺序的不可再现</a></h3>
<p>简单的 C 程序，从 CLI 参数读入对应的参数（序号），对应的序号参数由父进程通过 <code>execvp</code> 调用时传入；程序会将调用时传入的序号输出。</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[]) {
    printf(&quot;Process %s has start!\n&quot;, argv[1]);
    sleep(3);
    printf(&quot;Process %s finished!\n&quot;, argv[1]);
    return 0;
}
</code></pre>
<p>另一 C 程序，通过 fork 调用创建子进程，执行该程序。</p>
<pre><code class="language-cpp">#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    int status;
    char *const argv1[] = {&quot;./print&quot;, &quot;1&quot;, NULL};
    char *const argv2[] = {&quot;./print&quot;, &quot;2&quot;, NULL};
    char *const argv3[] = {&quot;./print&quot;, &quot;3&quot;, NULL};
    char *const argv4[] = {&quot;./print&quot;, &quot;4&quot;, NULL};

    pid_t pid[3];

    pid[0] = fork();
    if (pid[0] == 0) {
        execvp(argv1[0], argv1);
        // 根据 execvp 的行为，以下语句不会被执行
        sleep(1);
        execvp(argv2[0], argv2);
        sleep(1);
    }

    pid[1] = fork();
    if (pid[1] == 0) {
        execvp(argv3[0], argv3);
        sleep(1);
    }

    pid[2] = fork();
    if (pid[2] == 0) {
        execvp(argv4[0], argv4);
        sleep(1);
    }

    wait(&amp;status);
    wait(&amp;status);
    wait(&amp;status);

    printf(&quot;Main process finished.\n&quot;);
}
</code></pre>
<p>结果图</p>
<p><img src="lab/02/./assets/order-not-sure.png" alt="" /></p>
<p>可以看到两次执行的先后顺序不同。</p>
<h3 id="2-使用-wait-保证进程执行顺序"><a class="header" href="#2-使用-wait-保证进程执行顺序">2. 使用 wait 保证进程执行顺序</a></h3>
<p>使用 wait 即可使进程按顺序执行。</p>
<pre><code class="language-cpp">#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    int status;
    char *const argv1[] = {&quot;./print&quot;, &quot;1&quot;, NULL};
    char *const argv2[] = {&quot;./print&quot;, &quot;2&quot;, NULL};
    char *const argv3[] = {&quot;./print&quot;, &quot;3&quot;, NULL};
    char *const argv4[] = {&quot;./print&quot;, &quot;4&quot;, NULL};

    pid_t pid[3];

    pid[0] = fork();
    if (pid[0] == 0) {
        execvp(argv1[0], argv1);
        sleep(1);
    }
    wait(&amp;status);

    pid[1] = fork();
    if (pid[1] == 0) {
        execvp(argv3[0], argv3);
        sleep(1);
    }
    wait(&amp;status);

    pid[2] = fork();
    if (pid[2] == 0) {
        execvp(argv4[0], argv4);
        sleep(1);
    }
    wait(&amp;status);

    printf(&quot;Main process finished.\n&quot;);
}
</code></pre>
<p><img src="lab/02/./assets/order-sure.png" alt="" /></p>
<h3 id="3-测试进程最大数目"><a class="header" href="#3-测试进程最大数目">3. 测试进程最大数目</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验三-经典进程同步问题"><a class="header" href="#实验三-经典进程同步问题">实验三: 经典进程同步问题</a></h1>
<p>实验任务：</p>
<ol>
<li>掌握读者写者进程同步原理</li>
<li>掌握 Linux 系统的 system V 信号量机制</li>
<li>利用 system V 信号量机制, 实现读者写者进程同步问题</li>
</ol>
<p>备注: 要求至少两个以上读者, 两个以上写者, 共同访问一个文件. 在实验结果分析中, 分析多次运行的结果。备注不写入实验报告。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验四-进程通信"><a class="header" href="#实验四-进程通信">实验四: 进程通信</a></h1>
<p>实验任务：</p>
<ol>
<li>实现共享内存通信</li>
<li>实现管道通信</li>
<li>实现消息通信</li>
</ol>
<p>备注: 在消息通信实验中, 实现两个无关进程通信, 一个进程可循环发送字符串 (字符串每次从键盘输入), 另一进程接收发所有送来的字符串</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验五-页面置换算法"><a class="header" href="#实验五-页面置换算法">实验五: 页面置换算法</a></h1>
<p>实验任务</p>
<ol>
<li>掌握 OPT, LRU, FIFO页面置换算法原理</li>
<li>编程实现 OPT 或 LRU 页面置换算法, 计算缺页次数</li>
</ol>
<p>备注: 假设内存物理块为 3 或者 4, 访问的页面流信息通过输入设置, 模拟出内存的页面数据信息, 如1, *, * (此次算缺页); 1, 2, * (此次算缺页)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验六socket-网络通信"><a class="header" href="#实验六socket-网络通信">实验六：Socket 网络通信</a></h1>
<h2 id="一实验目的-2"><a class="header" href="#一实验目的-2">一、实验目的：</a></h2>
<ol>
<li>掌握 Socket 通信原理</li>
<li>编程实现一端可循环向另一端传送字符串</li>
<li>编程实现将一端某文件夹内容传送到另一端某位置</li>
</ol>
<p>备注：文件夹内可含有多级文件夹及文件 (备注不写入实验报告)</p>
<h2 id="二实验原理-2"><a class="header" href="#二实验原理-2">二、实验原理</a></h2>
<h2 id="三实验过程-1"><a class="header" href="#三实验过程-1">三、实验过程</a></h2>
<h2 id="四实验心得-1"><a class="header" href="#四实验心得-1">四、实验心得</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统课程设计"><a class="header" href="#操作系统课程设计">操作系统课程设计</a></h1>
<p><a href="lab-new/./01/">实验一: 多线程同步实验</a></p>
<p>参考搜索关键字: &quot;pthread programming&quot;</p>
<p><a href="lab-new/./02/">实验二: 添加内核模块</a></p>
<p>参考搜索关键字: &quot;linux kernel programming&quot;</p>
<p><a href="lab-new/./03/">实验三: 打印进程树</a></p>
<p><a href="lab-new/./04/">实验四: 添加系统调用</a></p>
<p><a href="lab-new/./05/">实验五: 虚拟文件系统</a></p>
<p><a href="lab-new/./06/">实验六: 块设备驱动程序</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验一-多线程同步实验"><a class="header" href="#实验一-多线程同步实验">实验一 多线程同步实验</a></h1>
<h2 id="实验目的"><a class="header" href="#实验目的">实验目的</a></h2>
<ol>
<li>掌握线程的概念及创建方法</li>
<li>掌握线程互斥锁及条件变量同步机制</li>
<li>掌握 POSIX 信号量机制</li>
<li>掌握生产者消费者原理</li>
<li>设计程序, 两种方法实现多线程生产者消费者同步问题</li>
</ol>
<p>(备注: 至少包括两个生产者线程, 两个消费者线程. 各生产者线程放的数据需要不同, 例如: 生产者 1 放 1, 2, 3, 4, 生产者 2 放 -2, -4, -6, 或者 3, 6, 9, 12. 备注不写入实验报告)</p>
<h2 id="实验原理"><a class="header" href="#实验原理">实验原理</a></h2>
<h3 id="线程的概念"><a class="header" href="#线程的概念">线程的概念</a></h3>
<p>线程 (<a href="https://en.wikipedia.org/wiki/Thread_(computing)" title="Thread (computing) - Wikipedia">thread</a>) 是操作系统能够进行运算调度的最小单位. 它被包含在进程之中, 是进程中的实际运作单位. 一个线程指的是进程中一个单一顺序的控制流, 一个进程中可以并发多个线程, 每条线程并行执行不同的任务. </p>
<p>线程是独立调度和分派的基本单位. 同一进程中的多个线程将共享该进程中的全部系统资源, 如虚拟地址空间, 文件描述符和信号处理等等. 但同一进程中的多个线程有各自的调用栈 (call stack), 自己的寄存器环境 (register context), 自己的线程本地存储 (thread-local storage).</p>
<p>一个进程可以有很多线程, 每个线程并行执行不同的任务. 在多核或多 CPU, 或支持 Hyper-threading 的 CPU 上使用多线程程序设计的好处是显而易见, 即提高了程序的执行吞吐率. 在单 CPU 单核的计算机上, 使用多线程技术, 也可以把进程中负责 I/O 处理, 人机交互而常被阻塞的部分与密集计算的部分分开来执行, 编写专门的线程执行密集计算, 从而提高了程序的执行效率. </p>
<h3 id="pthreads-和-libpthread"><a class="header" href="#pthreads-和-libpthread">pthreads 和 libpthread</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Pthreads" title="pthreads - Wikipedia">POSIX threads</a>, 通常以 <strong>pthreads</strong> 为人所知, 是一种独立于编程语言的线程执行模型 (或者称 &quot;并发模型&quot;). 它使得程序可以在同一时间控制多个不同的工作流. 每个工作流就是一个 &quot;线程 (<a href="https://en.wikipedia.org/wiki/Thread_(computing)" title="Thread (computing) - Wikipedia">thread</a>)&quot;, 而程序对于这些工作流的创建和控制, 则是通过对 <a href="https://en.wikipedia.org/wiki/POSIX" title="POSIX - Wikipedia">POSIX</a> Threads API 的调用来实现. 通常, POSIX 兼容的类 Unix 系统都会提供这些 API, 这些系统通常会包含一个 <strong>libpthread</strong> 库. <sup class="footnote-reference"><a href="#pthreads-wikipedia">1</a></sup></p>
<p><strong>pthreads</strong> 定义了一系列 C 语言的类型, 函数和常量, 在 <code>pthread.h</code> 和对应的线程库中实现. 有大约 100 中线程相关的过程 (procedure), 均以 <code>pthred_</code> 开头, 并且可以分为以下几组:</p>
<ul>
<li>线程管理 -- 线程的创建, 收集 (join) 等等.</li>
<li>互斥量</li>
<li>条件变量</li>
<li>使用读写锁实现的线程同步</li>
</ul>
<p>POSIX 信号量 (semaphore) 的 API 可以与 POSIX threads 协同使用, 但并不在线程的标准之中. 这些和信号量相关的函数通常以 <code>sem_</code> 开头, 而非 <code>pthread_</code>.</p>
<p>下面是一些关于线程的概念 <sup class="footnote-reference"><a href="#pthread-programming">2</a></sup>:</p>
<ul>
<li>线程并不会保存自己已经创建的线程, 也不知道创建自己的线程;</li>
<li>同一进程内的线程共享相同的地址空间;</li>
<li>每个线程都有独立的线程 ID, 寄存器环境, 调用栈, 优先级等等;</li>
<li>pthread 库函数返回 0 表示成功.</li>
</ul>
<div class="footnote-definition" id="pthreads-wikipedia"><sup class="footnote-definition-label">1</sup>
<p>翻译自 <a href="https://en.wikipedia.org/wiki/Pthreads" title="pthreads - Wikipedia">Wikipedia 上的 &quot;pthreads&quot; 词条</a></p>
</div>
<div class="footnote-definition" id="pthread-programming"><sup class="footnote-definition-label">2</sup>
<p>翻译自 <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">Linux Tutorial: POSIX Threads</a></p>
</div>
<h2 id="实验程序"><a class="header" href="#实验程序">实验程序</a></h2>
<h3 id="创建线程"><a class="header" href="#创建线程">创建线程</a></h3>
<p>pthread.h头文件中包含的几个基本概念及函数：
(1)pthread_t：. </p>
<p>线程ID数据类型, 线程ID只在它所属的进程环境中有效</p>
<p><code>pthread_create</code> 函数用于创建一个进程, 函数原型如下 <sup class="footnote-reference"><a href="#pthreads-tutorial">3</a></sup>:</p>
<pre><code class="language-cpp">int pthread_create(pthread_t *new_thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
</code></pre>
<ul>
<li>若成功创建新的线程, 函数将返回 0;</li>
<li>参数1: 传出参数, 用于保存成功创建线程之后对应的线程id. </li>
<li>参数2: 传入线程的属性, 通常传 NULL, 表示不修改线程的属性. </li>
<li>参数3: 传入一个指向函数的指针, 即待创建线程所执行函数的入口地址, 函数执行完毕, 则线程结束. </li>
<li>参数4: 传入调用线程所执行函数时所使用的参数. </li>
</ul>
<p>调用 <code>pthread_join</code> 的线程将被阻塞, 直到对应线程终止. </p>
<pre><code class="language-cpp">int pthread_join(pthread_t thread, void **rval_ptr);
</code></pre>
<ul>
<li>返回值:成功返回 0, 失败返回错误号</li>
<li>参数1: 回收线程的tid</li>
<li>参数2: 接收退出线程传递出的返回值</li>
</ul>
<p>线程以不同的方法终止时, 通过 <code>pthread_join</code> 得到的终止状态是不同的, 总结如下:</p>
<ul>
<li>如果 thread 线程通过 return 返回, <code>rval_ptr</code> 所指向的单元里存放的是 thread 线程函数的返回值. </li>
<li>如果 thread 线程被别的线程调用 <code>pthread_cancel</code> 异常终止掉, <code>rval_ptr</code> 所指向的单元里存放的是常量 <code>PTHREAD_CANCELED</code>. </li>
<li>如果 thread 线程是自己调用 <code>pthread_exit</code> 终止的, <code>rval_ptr</code> 所指向的单元存放的是传给 <code>pthread_exit</code> 的参数. </li>
</ul>
<p>如果 thread 线程的终止状态不感兴趣, 可以传 <code>NULL</code> 给 <code>rval_ptr</code> 参数. </p>
<p>简单的示例程序 <a href="lab-new/01/./thread_creation.c">thread_creation.c</a>: </p>
<pre><code class="language-cpp">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void *print_message_function(void *ptr) {
  printf(&quot;%s \n&quot;, (char *)ptr);
  return 0;
}

int main() {
  const char *message1 = &quot;Thread 1&quot;;
  const char *message2 = &quot;Thread 2&quot;;
  
  pthread_t thread1, thread2;

  pthread_create(&amp;thread1, NULL, print_message_function, (void *)message1);
  pthread_create(&amp;thread2, NULL, print_message_function, (void *)message2);

  pthread_join(thread1, NULL);
  pthread_join(thread2, NULL);

  exit(0);
}
</code></pre>
<p>需要注意, 编译文件时需要使用链接选项 <code>-lpthread</code>:</p>
<pre><code class="language-console">$ cc thread_creation.c -lpthread
$ ./a.out
Thread 1 
Thread 2 
</code></pre>
<p>进程的结束一般有以下几种情况.</p>
<ul>
<li>线程的任务完成, 即线程所执行的函数正常 <code>return</code>;</li>
<li>线程调用了 <code>pthread_exit</code> 函数;</li>
<li>其他线程调用 <code>pthread_cancel</code> 结束这个线程;</li>
<li>进程调用 <code>exec()</code> 或 <code>exit()</code>; </li>
<li><code>main</code> 函数先于线程执行结束, 且 <code>main</code> 没有等待线程完成任务.</li>
</ul>
<p>需要注意, 一个线程结束, 并不意味着它的所有信息都已经消失.</p>
<h3 id="线程互斥锁"><a class="header" href="#线程互斥锁">线程互斥锁</a></h3>
<h2 id="实验截图及结果分析"><a class="header" href="#实验截图及结果分析">实验截图及结果分析</a></h2>
<h2 id="实验心得"><a class="header" href="#实验心得">实验心得</a></h2>
<div class="footnote-definition" id="pthreads-tutorial"><sup class="footnote-definition-label">3</sup>
<p>摘自 <a href="https://hanbingyan.github.io/2016/03/07/pthread_on_linux/">pthreads 入门教程</a></p>
</div>
<p><a href="https://blog.gtwang.org/programming/pthread-multithreading-programming-in-c-tutorial/">C 语言 pthread 多线程并行程序设计入门教学与范例 - G. T. Wang</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验二-添加内核模块"><a class="header" href="#实验二-添加内核模块">实验二: 添加内核模块</a></h1>
<h2 id="实验目的-1"><a class="header" href="#实验目的-1">实验目的</a></h2>
<ol>
<li>掌握内核模块基本编程技术</li>
<li>向内核中添加一个内核模块, 打印进程控制块信息, 编译模块</li>
<li>加载、卸载模块</li>
</ol>
<blockquote>
<p>备注: 此模块要求返回当前运行进程 (CURRENT) 或者始祖进程 (init_task) 的进程控制块中的至少 30 项信息, 用中文标记含义. 此条备注不放入实验报告.</p>
</blockquote>
<h2 id="实验原理-1"><a class="header" href="#实验原理-1">实验原理</a></h2>
<p>内核模块 (kernel module) 是可以根据需要而被加载到内核中, 或从内核中卸载的代码. 这样便可以在运行过程中扩展内核的功能, 而无需重新引导系统.</p>
<p>举个例子, 设备驱动就是一种模块, 它让内核能够访问到连接到系统的硬件.</p>
<p>如果没有内核模块, 则不得不构建一个宏大的内核, 所有的新功能也都只能直接添加到内核镜像中.
除了内核将会非常巨大之外, 另一件麻烦事就是, 当每次想要添加新功能时, 都需要重新构建内核并重新引导系统.</p>
<ol>
<li>模块是 Linux 精心设计的一种机制, 可以用来动态增加内核的功能, 模块在内核空间运行. </li>
<li>Linux模块可以在内核启动过程中加载, 这称为静态加载. 也可以在内核运行的过程中随时加载, 这称为动态加载. </li>
<li>Linux中的大多数设备驱动程序或文件系统都被编译成模块, 因为它们数目繁多, 体积庞大, 不适合直接编译在内核中. 而通过模块机制, 在需要使用它们的时候, 在临时加载, 是最合适不过的. </li>
</ol>
<h3 id="linux-内核模块软件包"><a class="header" href="#linux-内核模块软件包">Linux 内核模块软件包</a></h3>
<p>在 Linux 发行版在一个软件包中提供了 <code>modprobe</code>, <code>insmod</code> 和 <code>depmod</code> 命令.</p>
<p>可以通过以下命令, 通过包管理器, 确保安装了所需的软件包 (构建工具和 <code>kmod</code>):</p>
<p>Ubuntu/Debian:</p>
<pre><code>sudo apt-get install build-essential kmod
</code></pre>
<p>Arch Linux:</p>
<pre><code>sudo pacman -S gcc kmod
</code></pre>
<h3 id="查看内核模块"><a class="header" href="#查看内核模块">查看内核模块</a></h3>
<p>使用 <code>lsmod</code> 命令查看内核当前已经加载的模块.</p>
<pre><code>sudo lsmod
</code></pre>
<p>内核模块都存储在 <code>/proc/modules</code> 文件中, 可以通过以下命令查看文件内容.</p>
<pre><code>sudo cat /proc/modules
</code></pre>
<h3 id="linux-内核头文件"><a class="header" href="#linux-内核头文件">Linux 内核头文件</a></h3>
<p>在开始构建之前, 需要确保安装了所使用内核对应的头文件.</p>
<h3 id="最简的内核模块示例"><a class="header" href="#最简的内核模块示例">最简的内核模块示例</a></h3>
<p>首先建立一个测试目录, 如 <code>~/dev/kernel/hello1/</code>.</p>
<p>并在目录下新建一个 C 程序源文件, 如 <a href="lab-new/02/./assets/hello/hello-1.c"><code>hello-1.c</code></a>.</p>
<p>其中至少包含两个函数:</p>
<ul>
<li><code>init_module()</code>: 模块加载的时候调用;</li>
<li><code>cleanup_module()</code>: 模块被卸载前调用.</li>
</ul>
<pre><code class="language-cpp">// hello1.c

#include &lt;linux/kernel.h&gt; /* Needed for pr_info() */
#include &lt;linux/module.h&gt; /* Needed by all modules */

int init_module(void)
{
	pr_info(&quot;Hello world 1.\n&quot;);

	/* A non 0 return means init_module failed; module can't be loaded. */
	return 0;
}

void cleanup_module(void)
{
	pr_info(&quot;Goodbye world 1.\n&quot;);
}

MODULE_LICENSE(&quot;GPL&quot;);
</code></pre>
<p>之后建立一个 <code>Makefile</code> 用于构建.</p>
<p>Linux 内核使用 <code>kbuild</code> 构建系统, <code>kbuild</code> 构建系统也可用于编译自定义的内核模块.</p>
<p>编译过程首先会到内核源码目录下, 读取顶层的 <code>Makefile</code> 文件, 然后再编译模块源码, 生成的内核模块后缀为 <code>.ko</code>.</p>
<p>Makefile 提供的 <code>obj-m</code> 表示对象文件 (object files) 编译成可加载的内核模块.</p>
<p><code>hello-1.c</code> 的 <code>Makefile</code> 文件 <code>obj-m += hello-1.o</code> 表明有一个模块要从目标文件 <code>hello-1.o</code> 建立, <code>kbuild</code> 从该目标文件建立内核模块 <code>hello-1.ko</code>.</p>
<pre><code>obj-m += hello-1.o
obj-m += hello-2.o
obj-m += showPCB.o

PWD := $(CURDIR)

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules 

clean: 
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
</code></pre>
<blockquote>
<p><code>Makefile</code> 中的缩进为 Tab 而非空格.</p>
</blockquote>
<ul>
<li><code>PWD := $(CURDIR)</code> 获得当前目录路径并存储在变量中;</li>
<li><code>-C</code> 是表示进入指定目录下, 执行对应目录下的 Makefile, 目的是为了找到并使用内核的顶层 Makefile;</li>
<li><code>M</code> 不是 <code>make</code> 命令的选项, 而是 Makefile 中使用的变量, 目的是为了使 Makefile 在试图建立模块目标前, 回到模块源码目录;</li>
<li><code>modules</code> 是 Makefile 中的目标;</li>
<li><code>uname</code> 命令用于显示当前操作系统名称. 传递 <code>-r</code> 选项则显示操作系统的发行版号</li>
<li><code>obj-m</code> 表示把 <code>hello.o</code> 文件作为 &quot;模块&quot; 进行编译, 不会编译到内核, 但是会生成一个独立的 &quot;<code>hello.ko</code>&quot; 文件;</li>
<li><code>obj-y</code> 表示把 <code>hello.o</code> 文件编译进内核.</li>
</ul>
<p>之后运行 <code>make</code> 命令进行构建.</p>
<p><img src="lab-new/02/./assets/hello1-build.png" alt="Building hello1" /></p>
<p>若不出问题, 则可以接下来可以在目录下看到编译得到的模块文件 <code>hello1.ko</code>. 可以用如下命令查看模块的信息:</p>
<pre><code>modinfo hello1.ko
</code></pre>
<p><img src="lab-new/02/./assets/hello1-info.png" alt="hello1 info" /></p>
<h3 id="加载模块"><a class="header" href="#加载模块">加载模块</a></h3>
<p>超级用户可以通过 <code>insmod</code> 和 <code>rmmod</code> 命令显式地 (手动) 将模块载入内核或从内核中将它卸载.</p>
<p>尝试载入上一步构建的 <code>hello-1</code> 模块:</p>
<pre><code>sudo insmod hello-1.ko
</code></pre>
<p>之后则可以通过 <code>lsmod</code> 确认已经载入内核模块:</p>
<pre><code>sudo lsmod | grep 'hello'
</code></pre>
<p>可以通过 <code>rmmod</code> 命令卸载模块:</p>
<pre><code>sudo rmmod hello_1
</code></pre>
<blockquote>
<p>模块名中的连字符 (dash) 会被替换为下划线. 如 <code>hello-1</code> 对应变换为 <code>hello_1</code>.</p>
</blockquote>
<p>可以在日志中查看如上发生的事情 (也可以使用 <code>dmesg</code> 命令).</p>
<pre><code>sudo journalctl --since &quot;1 hour ago&quot; | grep kernel
</code></pre>
<p><img src="lab-new/02/./assets/hello1-logs.png" alt="logs of loading and unloading hello1" /></p>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<p>一般来说, <code>init_module()</code> 函数要么用来向内核中注册某个服务的 handler, 要么替换掉某个内核函数的代码 (通常是做一些额外的事情, 然后再调用原来的函数). 而 <code>cleanup_module()</code> 函数则应该撤销 <code>init_module()</code> 所做的任何修改, 以保证模块可以被安全地卸载.</p>
<p>每个内核模块也都应该包含 <code>&lt;linux/module.h&gt;</code> 头文件. 引入 <code>&lt;linux/kernel.h&gt;</code> 只是为了 <code>pr_alert()</code> 日志等级的宏展开.</p>
<ol>
<li>关于代码风格: 内核编程的习惯, 是使用 Tab 缩进, 而不是空格.</li>
<li>引入用于输出的宏: 最初的时候, 有 <code>printk</code> 用于输出信息, 通常跟随一个优先级, 如 <code>KERN_INFO</code> 或者 <code>KERN_DEBUG</code>. 后来则可以使用宏, 以一种简化的形式表达, 如 <code>pr_info</code> 和 <code>pr_debug</code>.</li>
<li>关于编译: 内核模块的编译过程不同于运行在用户空间的一般程序. 早期的内核版本需要编程者关心大量的设定, 通常在 Makefile 文件中存储. 虽然以分层级的形式进行管理, 但是仍会有重复的设定项随着时间累积在子层级的 Makefile 文件中, 变得庞大而难以维护. 幸运的是, 一种叫做 <code>kbuild</code> 的新方式可以处理这些事情, 并且可加载的外部模块的构建过程完全被集成在了基础的内核构建机制中. 关于如何构建自定义模块的详情, 可以参考 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/kbuild/modules.rst">Documentation/kbuild/modules.rst</a> (<a href="https://www.kernel.org/doc/html/latest/kbuild/modules.html">在线阅读</a>).</li>
</ol>
<p>关于内核模块使用的 Makefile 的详细信息, 可以参考 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/kbuild/makefiles.rst">Documentation/kbuild/makefiles.rst</a> (<a href="https://www.kernel.org/doc/html/latest/kbuild/makefiles.html">在线阅读</a>)</p>
<p>在早期的内核版本中, 只能使用 <code>init_module</code> 和 <code>cleanup_moudle</code> 函数, 但现如今通过使用 <code>module_init</code> 和 <code>module_exit</code> 宏定义则可以使用任意的名字. 这些宏定义在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h">linux/module.h</a> 中, 使用时需要在源代码中包含. 需要注意的是, 在调用宏之前, 函数必须被先定义, 否则将在编译时产生错误.</p>
<pre><code class="language-cpp">// hello-2.c

#include &lt;linux/init.h&gt; /* Needed for the macros */
#include &lt;linux/kernel.h&gt; /* Needed for pr_info() */
#include &lt;linux/module.h&gt; /* Needed by all modules */

static int __init hello_2_init(void)
{
	pr_info(&quot;Hello, world 2\n&quot;);

	return 0;
}

static void __exit hello_2_exit(void)
{
	pr_info(&quot;Goodbye, world 2\n&quot;);
}

module_init(hello_2_init);
module_exit(hello_2_exit);

MODULE_LICENSE(&quot;GPL&quot;);
</code></pre>
<h2 id="实验过程"><a class="header" href="#实验过程">实验过程</a></h2>
<h3 id="向内核中添加一个内核模块-打印进程控制块信息-编译模块"><a class="header" href="#向内核中添加一个内核模块-打印进程控制块信息-编译模块">向内核中添加一个内核模块, 打印进程控制块信息, 编译模块</a></h3>
<p><a href="lab-new/02/./assets/showPCB/showPCB.c">showPCB.c</a></p>
<pre><code class="language-cpp">#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/sched.h&gt;


static int __init show_PCB_init(void)
{
	struct task_struct * now;
	now = current;

	pr_info(&quot;comm: %s\n&quot;, now-&gt;comm);
	pr_info(&quot;state: %d\n&quot;, now-&gt;pid);
	pr_info(&quot;exit_signal: %d\n&quot;, now-&gt;exit_signal);
	pr_info(&quot;pdeath_signal: %d\n&quot;, now-&gt;pdeath_signal);

	return 0;
}

static void __exit show_PCB_exit(void)
{
	pr_info(&quot;Goodbye, world.\n&quot;);
}

module_init(show_PCB_init);
module_exit(show_PCB_exit);

MODULE_LICENSE(&quot;GPL&quot;);
</code></pre>
<p><a href="lab-new/02/./assets/showPCB/Makefile">Makefile</a></p>
<pre><code>obj-m += showPCB.o

PWD := $(CURDIR)
BUILDDIR := /lib/modules/$(shell uname -r)/build

all:
	make -C $(BUILDDIR) M=$(PWD) modules 

clean: 
	make -C $(BUILDDIR) M=$(PWD) clean
</code></pre>
<h3 id="加载-卸载模块"><a class="header" href="#加载-卸载模块">加载, 卸载模块</a></h3>
<p><img src="lab-new/02/./assets/showPCB-logs.png" alt="showPCB logs" /></p>
<h3 id="返回当前运行进程-current-或始祖进程-init_task-的进程控制块中的至少-30-项信息"><a class="header" href="#返回当前运行进程-current-或始祖进程-init_task-的进程控制块中的至少-30-项信息">返回当前运行进程 (current) 或始祖进程 (init_task) 的进程控制块中的至少 30 项信息</a></h3>
<h2 id="实验心得-1"><a class="header" href="#实验心得-1">实验心得</a></h2>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<p><a href="https://github.com/sysprog21/lkmpg">sysprog21/lkmpg: The Linux Kernel Module Programming Guide</a>
(<a href="https://sysprog21.github.io/lkmpg/">在线阅读</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验三-打印进程树"><a class="header" href="#实验三-打印进程树">实验三: 打印进程树</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验四-添加系统调用"><a class="header" href="#实验四-添加系统调用">实验四: 添加系统调用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验五-虚拟文件系统"><a class="header" href="#实验五-虚拟文件系统">实验五: 虚拟文件系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验六-块设备驱动程序"><a class="header" href="#实验六-块设备驱动程序">实验六: 块设备驱动程序</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
