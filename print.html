<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OS Labs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom-style.css">
        <link rel="stylesheet" href="theme/css/custom-font.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">首页</a></li><li class="chapter-item expanded "><a href="lab/index.html"><strong aria-hidden="true">1.</strong> 操作系统实验</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lab/01/index.html"><strong aria-hidden="true">1.1.</strong> 实验一：Linux 的初步认识</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OS Labs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tsagaanbar/os-labs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="首页"><a class="header" href="#首页">首页</a></h1>
<h2 id="导航"><a class="header" href="#导航">导航</a></h2>
<p><a href="./lab/">操作系统实验</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统实验"><a class="header" href="#操作系统实验">操作系统实验</a></h1>
<p>《操作系统》课程是计算机科学与技术专业的主干课。操作系统是现代计算机系统中必不可少的基本系统软件，对计算机系统资源实施管理，是所有其他软件与计算机硬件的唯一接口，所有用户在使用计算机时都要得到操作系统提供的服务。</p>
<p>《操作系统》课程是一门理论和实践相结合的课程。通过《操作系统》实验教学，可以使学生深入地掌握操作系统的基本概念、基本原理，同时运用《操作系统》提供的方法与技巧对实际问题进行算法设计和程序设计，既能实现与课程同步练习、进一步深化理解和灵活掌握教学内容，又能培养学生程序设计及上机调试的能力。这将为学生《计算机体系结构》、《计算机网络》等后继课程的学习以及今后在相关领域的工作打下坚实的基础。</p>
<p>《操作系统》课程含有 18 学时的实验内容，要求学生完成 Linux 的初步认识、进程同步、进程通信、页面调度算法模拟等实验，使学生了解和掌握操作系统的基本原理，掌握常用操作系统的使用和一般的管理方法等内容。通过《操作系统》实践环节，培养学生认真分析问题、解决问题的能力，同时培养学生面对问题勤于思考及团队合作的意识，最终使学生达到理论与实践相结合的目的。</p>
<p>《操作系统》实验教学计划安排 6 个实验项目。由于每个项目都是一个综合训练，仅仅依靠上机三个学时是远远不够的，尤其是实验 6，具有很大的难度，教师可以根据学生的实际情况调整实验内容。这里要求每个同学上实验课前必须做好充分的准备，如问题的分析、数据类型和系统的设计以及程序的编写、初步的调试等等，上机实验课主要是教师和同学们一起讨论和交流，共同解决系统设计和调试中的问题。只有这样才能很好地达到实验教学的目的。</p>
<h2 id="索引"><a class="header" href="#索引">索引</a></h2>
<ul>
<li><a href="lab/./01/">实验一：Linux 的初步认识</a>
<ul>
<li><a href="lab/./01/#1-%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">安装过程</a></li>
<li><a href="lab/./01/#2-%E5%B8%B8%E8%A7%81-bash-%E5%91%BD%E4%BB%A4">常见 bash 命令</a></li>
<li><a href="lab/./01/#3-vi-%E7%BC%96%E8%BE%91%E5%99%A8">vi 编辑器</a></li>
<li><a href="lab/./01/#2-%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84-shell-%E7%A8%8B%E5%BA%8F">编写简单的 Shell 程序</a></li>
<li><a href="lab/./01/#3-%E8%AE%BE%E8%AE%A1-c-%E7%A8%8B%E5%BA%8F">设计 C 程序</a></li>
<li><a href="lab/./01/#4-makefile-%E6%96%87%E4%BB%B6">Makefile 文件</a></li>
<li><a href="lab/./01/#5-%E6%9E%84%E5%BB%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7cmake">构建管理工具：CMake</a></li>
<li><a href="lab/./01/#6-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9A%E6%97%B6%E5%90%AF%E5%8A%A8">程序的定时启动</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验一linux-的初步认识"><a class="header" href="#实验一linux-的初步认识">实验一：Linux 的初步认识</a></h1>
<p>实验课时：3学时</p>
<h2 id="一实验目的"><a class="header" href="#一实验目的">一、实验目的</a></h2>
<ol>
<li>了解 Linux 发行版（Ubuntu）的安装过程</li>
<li>掌握基本的 Shell 命令（bash）</li>
<li>了解 vi 编辑器的使用</li>
<li>设计一个 Shell 程序</li>
<li>设计 C 程序，在 Shell 下使用 gcc 编译器编译 C 程序</li>
<li>设计一个 Makefile 文件</li>
</ol>
<h2 id="二实验原理"><a class="header" href="#二实验原理">二、实验原理</a></h2>
<h3 id="1-安装过程"><a class="header" href="#1-安装过程">1. 安装过程</a></h3>
<p>在主机上安装并使用虚拟机软件（如 VMware Workstation、Oracle VirtualBox 等），建立一个虚拟机。</p>
<p>针对 Ubuntu 的配置，可以选择 2 × CPU + 2 GB RAM 以及 20 GB 以上的磁盘空间，或遵循虚拟机软件的默认配置。</p>
<p>接着需要获取安装介质。可以在官方网站获取 Ubuntu 的安装镜像。</p>
<p>将安装介质装载在虚拟机（客户机）上，启动虚拟机。由于虚拟机“物理驱动器”上默认无操作系统，便会从“光盘驱动器”启动。“光盘驱动器”中装载的即为 Ubuntu 的安装镜像。</p>
<p>之后进行简单的配置。在设置用户名时，可以选择简单的用户名和密码组合，以便输入。</p>
<p>首次进入系统后，可以将软件包源配置为易于访问的镜像源。软件包提供方即为软件源，用户可以通过包管理器获得软件源下所提供的软件包。包管理器会在本地存取一份软件源下可用的软件包列表，即软件源缓存。切换软件源后、每次安装或更新软件包前，最好应该执行一次刷新软件源的操作。</p>
<p>可以在 Ubuntu 桌面应用列表中找到“Software &amp; Updates”应用，更改其中的软件源。Ubuntu 官方下载的镜像安装的系统中包含诸多已有的镜像源。比如，我们可以选择“China”下的“<a href="https://mirrors.ustc.edu.cn/">https://mirrors.ustc.edu.cn/</a>”。确认选择后，点击 Close 关闭应用，会提示用户进行刷新软件包缓存。</p>
<p>用户也可按下 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>T</kbd> 组合键，或在应用列表中打开“终端（Terminal）”应用，在 Shell 中以超级用户（Super User）权限执行 <code>apt update</code> 命令<strong>刷新软件源缓存</strong>。</p>
<p>在首次使用前，还建议执行一次<strong>更新软件包</strong>的操作，即 <code>apt upgrade</code>：</p>
<pre><code class="language-console">$ sudo apt upgrade
</code></pre>
<blockquote>
<p>用户默认以普通用户身份登入，需要使用 <code>sudo</code> 来执行需要提权的操作。上述代码块中，行首的 <code>$</code> 表示目前处于普通用户模式，在输入命令时无需输入。</p>
<p>在一次终端会话中首次使用 <code>sudo</code> 时，会要求用户输入自己的密码。需要注意，键入密码不会回显，输入完成后按 <kbd>Enter</kbd> 提交即可。</p>
</blockquote>
<p>更新完成后，可以重启一次客户机中的系统。</p>
<p>接下来安装一些其他开发所需软件包，如 C/C++ 编译器、git、CMake 等。可以通过安装 <code>build-essential</code> 伪包来安装构建所需的诸软件包。</p>
<pre><code class="language-console">$ sudo apt install build-essential git cmake
</code></pre>
<h3 id="2-常见-bash-命令"><a class="header" href="#2-常见-bash-命令">2. 常见 bash 命令</a></h3>
<p>默认情况下，打开终端，其中运行的就是 Shell 程序。Shell 程序可以解析用户的输入，从而执行用户的指令，比如对计算机（系统）进行操作、运行其他程序。</p>
<p>Ubuntu 默认的 Shell 程序为 bash，有如下常见的命令。</p>
<ul>
<li>cd：改变当前目录命令</li>
<li>pwd：显示目前所在目录的指令</li>
<li>ls：列出指定目录的内容</li>
<li>mkdir：建立目录</li>
<li>cp：文件复制命令</li>
<li>rm：删除文件或目录</li>
<li>mv：文件移动、重命名</li>
<li>chmod：变更档案属性</li>
<li>df：查看系统的文件系统的空间使用情况</li>
<li>du：查看具体某个文件和目录的磁盘空间的占用情况</li>
<li>clear：清除终端中的输出</li>
<li>whoami：查看当前登录用户名</li>
</ul>
<p>用户可以使用“命令行选项”来控制命令的执行，即，向其传递（pass）命令行参数。</p>
<p>如，可以为 <code>ls</code> 命令添加 <code>-l</code> 参数，使其以列表形式输出目录下的内容；亦可以添加 <code>-a</code> 参数，使其输出目录下所有文件及子目录（包含隐藏文件和目录）。</p>
<p>有时候，我们可以将这种单字母的指令组合在一起，即，<code>ls -l -a</code> 等价于 <code>ls -la</code>。</p>
<p>用户还可自定义别名（alias），来简化命令的输入。比如，Ubuntu 默认启用了 <code>la</code> 和 <code>ll</code> 这两个别名，分别对应着 <code>ls -a</code> 和 <code>ls -la</code>。</p>
<p>有关<strong>管道</strong>、<strong>输出重定向</strong>、<strong>PATH 环境变量</strong>、<strong>任务控制</strong>等详情，另请阅读：</p>
<ul>
<li><a href="https://tsagaanbar.gitee.io/newly-programmer-abc/begin-programming/cli/cli-and-shell.html">命令行与 Shell 程序 - 程序员入门指南</a></li>
<li><a href="https://tsagaanbar.gitee.io/newly-programmer-abc/begin-programming/cli/common-commands.html">一些常用 Shell 命令 - 程序员入门指南</a></li>
<li><a href="https://tsagaanbar.gitee.io/newly-programmer-abc/begin-programming/cli/common-cli-tools.html">一些常用命令行工具 - 程序员入门指南</a></li>
</ul>
<p><code>ls -l</code> 命令输出类似如下：</p>
<pre><code class="language-console">$ ls -l
total 12
drwxr-xr-x 2 henry henry 4096 Jul 18 04:50 clash
drwxr-xr-x 6 henry henry 4096 Oct  3 22:31 cwork
-rw-r--r-- 1 henry henry    0 Oct  7 16:04 hello.txt
-rwxr-xr-x 1 henry henry  925 Apr 24 18:09 proxy.sh
</code></pre>
<figure>
<p><img src="lab/01/./assets/ls-color-output.svg" alt="终端输出文本有色彩高亮显示" title="添加了高亮的终端输出文本示例" /></p>
<figcaption>图 1：终端输出文本有色彩高亮显示</figcaption>
</figure>
<p>可以看到，每行行首有诸如 <code>drwxr-xr-x</code> 这样的字符串，第一个字符表示文件类型，如 <code>d</code> 表示文件为目录、<code>-</code> 表示文件为普通文件、<code>l</code> 表示文件为链接。剩余字符三个一组，分别表示所有者权限、所有者同组用户权限，以及其他用户权限。</p>
<p>可以使用 <code>chmod</code> 命令<strong>修改文件权限</strong>。<code>chmod</code> 命令的常用格式如下：</p>
<pre><code>chmod [OPTION]... MODE[,MODE]... FILE...
</code></pre>
<p>即，按照 <code>MODE</code> 所指定的规则修改某 <code>FILE</code> 的模式位。<code>MODE</code> 的格式为 <code>[ugoa...][[-+=][perms...]]</code>，其中 <code>perms</code> 可以是 <code>rwxXst</code> 之中的字母，如有多个字母，则以逗号 <code>,</code> 间隔。</p>
<p><code>ugoa</code> 的组合表述该次修改所针对的用户：</p>
<ul>
<li><code>u</code>：文件的所有者</li>
<li><code>g</code>：文件所有者所在组中的其他用户</li>
<li><code>o</code>：不在文件所有者所在组中的用户，即除了 <code>u</code> 和 <code>g</code> 之外的用户</li>
<li><code>a</code>：所有用户</li>
</ul>
<p>如果不指定 <code>chmod</code> 所针对的用户，则默认为所有用户。</p>
<p><code>+</code> 运算符表示增加对应的权限，<code>-</code> 运算符表示移除对应的权限，<code>=</code> 将增加对应的权限，而移除其余未指定的权限。</p>
<p><code>rwxX</code> 分别代表：</p>
<ul>
<li><code>r</code>：读（read）权限</li>
<li><code>w</code>：写（write）权限</li>
<li><code>x</code>：可执行（execute）权限，或可检索目录权限</li>
<li><code>X</code>：仅当某用户对该文件拥有 <code>x</code> 权限、或该文件为目录时，才增添 <code>x</code> 权限</li>
</ul>
<p>此外，可以使用 <code>ugo</code> 中的一个字母，来代指：</p>
<ul>
<li><code>u</code>：文件所有者具有的权限</li>
<li><code>g</code>：同组其他用户具有的权限</li>
<li><code>o</code>：非 <code>u</code> 或 <code>g</code> 类用户所具有的权限。</li>
</ul>
<p>数码形式的模式使用 1 - 4 个八进制数码来表示，每个数码由 4、2、1 相加而得。省略的数码将被视作前导 0 来处理。第 2 - 4 位八进制数分别表示 <code>u</code>、<code>g</code>、<code>o</code> 的权限，每个数字由 4、2、1 三个数字相加而得。</p>
<ul>
<li>4, (100)<sub>2</sub>：代表 <code>r</code> 权限</li>
<li>2, (010)<sub>2</sub>：代表 <code>w</code> 权限</li>
<li>1, (001)<sub>2</sub>：代表 <code>x</code> 权限</li>
</ul>
<p>比如，<code>chmod a+x file</code> 就是为所有用户添加 <code>file</code> 的可执行权限，其等价于 <code>chmod +111 file</code>。</p>
<p>或者，要修改一个文件为“当前用户 <code>rwx</code> 权限”“其他用户仅拥有 <code>rx</code> 权限”，则可以使用 <code>chmow 755 file</code>。</p>
<blockquote>
<p>可以使用 <code>man chmod</code> 查看关于 <code>chmod</code> 命令的详细说明。</p>
</blockquote>
<p>可以使用 <code>useradd</code> 命令<strong>创建用户</strong>。直接键入 <code>useradd</code> 命令，或者添加 <code>-h</code> 选项，可以看到相关帮助信息。</p>
<p>使用 <code>-m</code> 参数，会为用户在 <code>/home/</code> 目录下创建与用户名同名的用户目录。</p>
<p>假设新建的用户名为 <code>john</code>：</p>
<pre><code class="language-console">$ sudo adduser john -m
</code></pre>
<p>创建用户成功后，新的用户名会写入在 <code>/etc/passwd</code> 文件中，可以通过 <code>cat</code> 或者 <code>grep</code> 命令检验：</p>
<pre><code class="language-console">$ grep '^john' /etc/passwd
john:x:1001:1001::/home/john:/bin/sh
</code></pre>
<p>还可以使用 <code>-G</code> 命令将用户添加到某用户组。如 <code>-G sudo</code> 可以使新建的用户能够使用 <code>sudo</code>，即“拥有管理员权限”。</p>
<pre><code class="language-console">$ sudo useradd -m jason -G sudo
</code></pre>
<p>使用 <code>passwd</code> 命令<strong>修改用户密码</strong>。直接键入 <code>passwd</code> 命令可以修改自己的密码，使用 <code>sudo passwd &lt;username&gt;</code> 修改其他用户的密码。</p>
<pre><code class="language-console">$ sudo passwd jason
</code></pre>
<p>首先需要提供用户当前的密码（如有），之后，要输入两次新密码以确认更改。</p>
<p>可以使用 <code>userdel</code> 命令<strong>删除用户</strong>，附加 <code>-r</code> 参数将同时移除用户的家目录和邮件池。</p>
<pre><code class="language-console">sudo userdel -r john
</code></pre>
<h3 id="3-vi-编辑器"><a class="header" href="#3-vi-编辑器">3. vi 编辑器</a></h3>
<p>基本使用：</p>
<ul>
<li>使用 <code>vi</code> 和某文件名以打开某文件进行编辑，如 <code>vi some.txt</code>；若文件不存在，则将会被创建；</li>
<li>甫一进入程序时为命令模式，按 <code>i</code> 键（键入小写字母 <code>i</code>）进入插入模式，之后的输入将会存入缓存；</li>
<li>按 <kbd>ESC</kbd> 退出插入模式，回到命令模式；</li>
<li>输入以下命令：
<ul>
<li><code>:q</code> 退出程序。如果进行了修改，则无法直接退出；</li>
<li><code>:q!</code> 退出程序并放弃修改；</li>
<li><code>:wq</code> 将改动写入文件并退出。</li>
</ul>
</li>
</ul>
<p>在命令模式下，可以：</p>
<ul>
<li>按 <code>h</code>、<code>l</code> 左右移动光标，按 <code>j</code>、<code>k</code> 上下移动光标</li>
<li>按 <code>x</code> 可以删除字符</li>
<li>按 <code>dd</code> 可以删除当前所在的行</li>
</ul>
<p>要进入插入模式，除了可以按 <code>i</code> 键，还有更多的选择：</p>
<ul>
<li><code>i</code>: 在<strong>光标左侧</strong>输入正文</li>
<li><code>a</code>: 在<strong>光标右侧</strong>输入正文</li>
<li><code>I</code>: 在光标所在行的<strong>行首</strong>输入正文</li>
<li><code>A</code>: 在光标所在行的<strong>行尾</strong>输入正文</li>
<li><code>o</code>: 在光标所在行的下一行增添新行，光标位于新行的行首</li>
<li><code>O</code>: 在光标所在行的上一行增添新行，光标位于新行的行首</li>
</ul>
<blockquote>
<p>事实上，在有图形界面时，可以不必在命令行界面下编辑文本。Ubuntu 自带的 GNOME 桌面提供有 <code>gedit</code> 工具，使用方法类似，即在 Shell 中执行 <code>gedit &lt;filename&gt;</code>，即可打开一个<strong>图形化的编辑界面</strong>。亦可安装自己喜欢的编辑器，如 <a href="https://code.visualstudio.com">Visual Studio Code</a>。</p>
</blockquote>
<h2 id="三实验过程"><a class="header" href="#三实验过程">三、实验过程</a></h2>
<h3 id="1-熟悉常用的-bash-命令"><a class="header" href="#1-熟悉常用的-bash-命令">1. 熟悉常用的 bash 命令</a></h3>
<h3 id="2-编写简单的-shell-程序"><a class="header" href="#2-编写简单的-shell-程序">2. 编写简单的 Shell 程序</a></h3>
<p><a href="lab/01/./hello.sh">hello.sh</a></p>
<pre><code class="language-bash">#!/bin/bash
ls
echo &quot;ls 命令显示完毕&quot;
pwd
echo &quot;pwd 命令显示完毕&quot;
echo &quot;Welocme, $LOGNAME! It's now $(date +%T).&quot;
echo &quot;&quot;
echo &quot;c: View month calendar&quot;
echo &quot;e: View a file&quot;
echo &quot;q: Exit&quot;

echo &quot;Input your choice:&quot;
read choice

case $choice in
    c|C) echo &quot;Month:&quot;
        read month
        echo &quot;Year&quot;
        read year
        cal $month $year # 调用 cal 命令打印月历
    ;;
    e|E) echo &quot;Viewing a file. Input file name:&quot;
        read file
        if  [ -f $file ] ;
        then
            more $file
        else
            echo &quot;This file doesn't exist.&quot;
            exit 1
        fi
    ;;
    q|Q)  echo &quot;Bye!&quot;
        exit 0
    ;;
    *) echo &quot;Illegal choice '$choice'.&quot;
        exit 1
    ;;
esac  # end of cases

echo &quot;The end!&quot;
</code></pre>
<p>文件最开始的 <code>#!/bin/bash</code> 称为 Shebang。在计算领域中，Shebang（也称为 Hashbang）是一个由井号和叹号构成的字符序列（<code>#!</code>），其出现在文本文件的第一行的前两个字符。在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。例如，在终端中输入一个 Shebang 内容为 <code>#!/bin/bash</code> 的文件的路径 <code>path/to/script</code>，则相当于使用 <code>/bin/bash</code> 处的可执行程序解释运行 <code>path/to/script</code> 处的脚本，即 <code>/bin/bash path/to/script</code> 命令。</p>
<p>也就是说，得益于这种机制，脚本文件也可以像一个可执行程序一样来使用。不过，在这之前，还需要为脚本添加可执行的权限。有些时候，下载的可执行文件缺失了信息，也需要重新为其添加可执行权限。</p>
<pre><code class="language-console">$ chmod +x ./hello.sh
$ ./hello.sh
</code></pre>
<blockquote>
<p><code>./hello.sh</code> 是 <code>hello.sh</code> 这个脚本文件的路径，即当前目录下的 <code>hello.sh</code>。对于不在 <code>PATH</code> 环境变量的中的路径下面的可执行程序，需要使用路径以指定运行。</p>
</blockquote>
<p>通过下面的脚本，可以以递归的方式遍历目录下的所有文件。</p>
<p><a href="lab/01/./read-dir.sh">read-dir.sh</a></p>
<pre><code class="language-bash">#!/bin/bash

read_dir() # 递归输出目录下的所有文件
{
    for file in `ls $1`         # 遍历指定目录下的所有文件
    do
        if [ -d $1&quot;/&quot;$file ]    # 判断是目录
        then
            read_dir $1&quot;/&quot;$file
        else
            echo $1&quot;/&quot;$file
            # ./a.out  $1&quot;/&quot;$file   # 可自定义可执行程序
        fi
    done
}

read_dir $1
</code></pre>
<p>对这个脚本稍作修改，可以实现拷贝所有文件到另一个路径下。除此之外，也可以使用带 <code>-r</code> 参数的 <code>cp</code> 命令。</p>
<p><a href="lab/01/./copy-dir.sh">copy-dir.sh</a></p>
<pre><code class="language-bash">#!/bin/bash

copy_dir() # 递归拷贝目录下的所有文件
{
    for file in `ls $1`         # 遍历指定目录下的所有文件
    do
        if [ -d $1&quot;/&quot;$file ]    # 判断是目录，则：
        then
            mkdir $2&quot;/&quot;$file    # 1. 在目标目录下创建同名目录
            copy_dir $1&quot;/&quot;$file # 2. 对这个目录执行递归的操作
        else
            # 如果不是目录，则拷贝该文件到对应目录下的同名文件
            cp $1&quot;/&quot;$file $2&quot;/&quot;$file
        fi
    done
}

copy_dir $1 $2
</code></pre>
<h3 id="3-设计-c-程序"><a class="header" href="#3-设计-c-程序">3. 设计 C 程序</a></h3>
<p>不同于 Shell 脚本由 Shell 程序解释执行，使用 C/C++ 编写的程序需要经过<strong>编译</strong>、<strong>链接</strong>之后生成可执行程序，才能运行。</p>
<p>下面是两个简单的 C/C++ 程序：</p>
<p>【C】 <a href="lab/01/./hello.c">hello.c</a></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello!\n&quot;);
    return 0;
}
</code></pre>
<p>【C++】 <a href="lab/01/./hello.cpp">hello.cpp</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; &quot;Hello!\n&quot;;
    return EXIT_SUCCESS;
}
</code></pre>
<p>在编译 C/C++ 程序之前，需要确保安装了 C/C++ 的编译器。可以在终端中输入 <code>c++ --version</code> 尝试，如果存在可用的编辑器，将会输出对应的版本信息。</p>
<blockquote>
<p>如前所说，类似 <code>-v</code> 和 <code>--version</code> 是 GNU 风格的命令行选项风格。而 Windows 下原生的命令行程序一般采用不同的风格，一般来说使用 <code>/</code> 开头的选项，比如 <code>/?</code>。不过，一些 Windows 下的命令也开始兼容类似 GNU 风格的参数，一些从 *nix 迁移到 Windows 的命令行程序也会保留原来的参数风格。</p>
</blockquote>
<p>如果尚未安装 C/C++ 编译器，可以通过包管理器安装。在 Ubuntu 下，可以安装 GNU 的 gcc 编译器。</p>
<p>一般来说，在安装了编译器后，系统会将 <code>cc</code>、<code>c++</code> 命令关联到可以使用的 C 和 C++ 编译器上。当然，也可以显式指明要使用的编译器。</p>
<p>将需要编译的 C/C++ 源文件传递给对应的编译器即可。输出的可执行文件名默认为当前目录下的 <code>a.out</code> 文件。</p>
<p>如果没有错误，执行命令后将不会额外的提示。如果有，可以观察提示的信息，进行相应的修改。</p>
<pre><code class="language-console">$ cc hello.c
$ ls -l
total 28
-rwxr-xr-x 1 henry henry 16696 Oct  9 00:06 a.out
-rw-r--r-- 1 henry henry    60 Oct  9 00:03 hello.c
-rw-r--r-- 1 henry henry    91 Oct  9 00:03 hello.cpp
</code></pre>
<p>可以看到，生成的 <code>a.out</code> 文件具备可执行权限。直接在 Shell 中输入其路径即可执行该程序。</p>
<pre><code class="language-console">$ ./a.out
Hello!
</code></pre>
<figure>
<p><img src="lab/01/./assets/c-compile-and-run.svg" alt="在 bash 中编译 C 语言源代码并运行程序的示意图" title="在 bash 中编译 C 语言源代码并运行程序的示意图" /></p>
<figcaption>图 2：在 bash 中编译 C 语言源代码并运行程序的示意图</figcaption>
</figure>
<p>可以使用带参数的 <code>-o</code> 选项，来指定输出文件的路径及名称。</p>
<pre><code class="language-console">$ cc hello.c -o main
$ ls -l
total 48
-rwxr-xr-x 1 henry henry 16696 Oct  9 00:26 a.out
-rw-r--r-- 1 henry henry    60 Oct  9 00:03 hello.c
-rw-r--r-- 1 henry henry    91 Oct  9 00:03 hello.cpp
-rwxr-xr-x 1 henry henry 16696 Oct  9 00:27 main
</code></pre>
<p>对于 C++ 源文件，需要使用 C++ 编译器，即使用 <code>c++</code> 命令，或显式指定使用 <code>g++</code> 编译器。</p>
<pre><code class="language-console">$ c++ hello.cpp -o hello
$ ./hello
Hello!
</code></pre>
<p>之前提到过，C/C++ 程序源代码需要经过预处理、编译、链接之后才能运行。事实上，在代码中包含了如 <code>&lt;iostream&gt;</code> 等头文件，只能使代码通过编译，但这时的代码还不清楚所使用的函数的具体实现，还需要链接到 C/C++ 的标准库，并且对最后生成的可执行文件进行一定的封装，才能在对应系统上运行。</p>
<p>在上述的命令操作中，编译器默认对传递进的源代码进行了编译、链接的操作，输出的即为最终的可执行程序。我们也可以传递不同的选项，来逐步进行这个流程。</p>
<blockquote>
<p>C 语言编译器默认链接到 C 语言的库。C++ 编译器默认兼容 C 语言的源文件输入。但如果使用 C 编译器处理 C++ 的源代码，就会在链接阶段出现找不到符号的错误：</p>
<pre><code class="language-console">$ cc hello.cpp
/usr/bin/ld: /tmp/ccqnkM7m.o: in function `main':
hello.cpp:(.text+0x12): undefined reference to `std::cout'
... 省略若干输出
collect2: error: ld returned 1 exit status
</code></pre>
</blockquote>
<p>简单来说，可以先编译源代码生成目标文件，之后再链接生成可执行文件。</p>
<p>可以使用 <code>--help</code> 选项，查看 <code>gcc</code> 的帮助信息：</p>
<pre><code class="language-console">$ gcc --help
Usage: gcc [options] file...
Options:
  -pass-exit-codes         Exit with highest error code from a phase.
  --help                   Display this information.
... 省略若干输出
  -E                       Preprocess only; do not compile, assemble or link.
  -S                       Compile only; do not assemble or link.
  -c                       Compile and assemble, but do not link.
  -o &lt;file&gt;                Place the output into &lt;file&gt;.
... 省略若干输出
</code></pre>
<p>可以看到，使用 <code>-E</code> 选项将仅进行预处理；使用 <code>-S</code> 选项仅编译，但不进行汇编和链接；<code>-c</code> 选项将对文件进行编译（compile）和汇编（assemble），但不链接（link）。</p>
<pre><code class="language-console">$ c++ -c hello.cpp
$ ls -l
total 8
-rw-r--r-- 1 henry henry   91 Oct  9 00:03 hello.cpp
-rw-r--r-- 1 henry henry 2736 Oct  9 00:47 hello.o
</code></pre>
<p>使用 <code>-c</code> 选项后，生成了扩展名为 <code>.o</code> 的目标文件（object file）。</p>
<p>将目标文件作为输入，输出可执行程序。</p>
<pre><code class="language-console">$ c++ hello.o -o main
$ ls -l
total 28
-rw-r--r-- 1 henry henry    91 Oct  9 00:03 hello.cpp
-rw-r--r-- 1 henry henry  2736 Oct  9 00:47 hello.o
-rwxr-xr-x 1 henry henry 17168 Oct  9 00:48 main
</code></pre>
<h3 id="4-makefile-文件"><a class="header" href="#4-makefile-文件">4. Makefile 文件</a></h3>
<p>使用多文件编程，可以减少编译时消耗的时间。编译时，每个源代码文件被视作一个编译单位。如果将项目中的代码分别放在若干源文件中，那么，未经修改的代码就不需要重新编译，这样就能够节省编译时间。最后只需要将目标文件重新链接起来，即可生成新的可执行程序。</p>
<p>在一个源文件中，如果需要使用到其他文件中的符号，需要得知关于符号的声明才能通过编译。链接时，则会寻找这些符号的定义。如果没有找到对应符号的定义，则会出现“未解决符号（Unresolved symbols）”或者“未定义引用（Undefined Reference）”的问题。</p>
<p>如果我们将符号的声明和具体实现放在不同的文件里，就可以方便互相之间的使用。我们将存放声明的文件称为头文件（headers）或者包含（include）文件。这样，负责实现头文件中声明的文件、使用这些符号的其他文件，都只需要包含这个头文件，就能够通过编译。</p>
<blockquote>
<p>可以看到，头文件有可能会被多个源代码文件包含。因此，如果在头文件中直接编写了函数的具体定义，就有可能出现“重复定义”的错误。换言之，在链接时，链接器会查找到多个同名符号。如果有需要在头文件中定义符号，可以将其声明为 <code>inline</code>。此外，如果不同编译单元中使用了同名的不同符号，又不希望相互影响，可以将其声明为 <code>static</code>，这样该符号便不会在链接时暴露于外部。</p>
</blockquote>
<blockquote>
<p>存在一个头文件包含了其他头文件的情况，如果某个文件包含了这样的头文件，且同时包含了该头文件所包含的其他头文件，就会造成重复包含的问题。因此，需要保证每个头文件在一个编译单元中仅被包含一次，也就是，需要为头文件添加“头文件保护（Header Guard）”。</p>
</blockquote>
<blockquote>
<p>有时，头文件中的内容十分繁多。由于包含过程只是相当于将头文件整个复制进源代码文件，复杂的头文件也会造成编译时间的大大增加。因此，会有一些技术来减少这部分的编译时间。</p>
</blockquote>
<p>假设我们的多文件程序如下所示：</p>
<p><a href="lab/01/./multi-files/functions.h">functions.h</a></p>
<pre><code class="language-cpp">#ifndef FUNCTIONS_H
#define FUNCTIONS_H

int f(int x);

#endif
</code></pre>
<p><a href="lab/01/./multi-files/functions.c">functions.c</a> </p>
<pre><code class="language-cpp">#include &quot;functions.h&quot;

int f(int x) { return x * 2; }
</code></pre>
<p><a href="lab/01/./multi-files/hello.c">hello.c</a>:</p>
<pre><code class="language-cpp">#include &quot;functions.h&quot;
#include &quot;stdio.h&quot;

int main() {
    printf(&quot;Welcome, Henry.\n&quot;);
    int x1 = 5;
    int x2 = 6;
    int x3 = 7;
    printf(&quot;The result of f(%d) is %d.\n&quot;, x1, f(x1));
    printf(&quot;The result of f(%d) is %d.\n&quot;, x2, f(x2));
    printf(&quot;The result of f(%d) is %d.\n&quot;, x3, f(x3));
    return 0;
}
</code></pre>
<blockquote>
<p><code>hello.c</code> 包含 <code>main</code> 函数。C/C++ 程序默认将从 <code>main</code> 函数执行。即，生成的可执行程序中需要有，且只有一个 <code>main</code> 函数。</p>
</blockquote>
<p>假设将这些文件放在同一个目录下。可以使用 <code>cat</code> 命令将文件内容输出在终端。</p>
<p>要运行以上的多文件程序，我们可以逐个编译源代码文件、得到对应的目标文件，而后将他们链接起来，生成可执行程序。</p>
<pre><code class="language-console">$ cc -c functions.c
$ cc -c hello.c
$ ls -l
total 20
-rw-r--r-- 1 henry henry   47 Oct  9 01:31 functions.c
-rw-r--r-- 1 henry henry   30 Oct  9 01:30 functions.h
-rw-r--r-- 1 henry henry 1368 Oct  9 01:36 functions.o
-rw-r--r-- 1 henry henry  330 Oct  9 01:30 hello.c
-rw-r--r-- 1 henry henry 2112 Oct  9 01:42 hello.o
$ cc functions.o hello.o -o main
$ ./main
Welcome, Henry.
The result of f(5) is 10.
The result of f(6) is 12.
The result of f(7) is 14.
</code></pre>
<p>可以看到，要完成上述的编译、链接操作，我们需要键入 3 条命令。随着文件数目的增多、构建过程的复杂，输入的命令将会越来越多。</p>
<p>不过，我们可以在 <code>make</code> 工具的帮助下进行构建操作。执行 <code>make</code> 命令，会按照目录下的名为 <code>Makefile</code> 的文件执行相应的操作。</p>
<p>对于一个简单工程来说，我们一般希望：</p>
<ol>
<li>如果工程没有编译过，那么所有源代码文件都要编译并被链接；</li>
<li>如果工程的某几个源代码文件被修改，那么只编译被修改的文件，并链接生成目标可执行程序；</li>
<li>如果工程中的头文件被改变了，那么需要重新编译引用了这几个头文件的源代码文件，并链接生成目标可执行程序。</li>
</ol>
<p>只要书写了正确的 Makefile 文件，<code>make</code> 工具可以帮我们实现上述这些功能。</p>
<p>Makefile 由若干规则组成，每个规则描述了以何种方式生成一个目标，以及该目标所需的依赖。格式如下：</p>
<pre><code class="language-makefile">target ... : prerequisites ...
    command
    ...
</code></pre>
<ul>
<li>target：可以是一个目标文件，也可以是一个执行文件，还可以是一个标签（label）；</li>
<li>prerequisites：生成该 target 所依赖的文件和/或其他 target；</li>
<li>command：生成 target 所要执行的命令（任意的 Shell 命令）。</li>
</ul>
<p>可以看到，我们规则描述出文件的依赖关系，也就是说，一个 target 依赖于某些 prerequisites，而 target 生成规则定义在 command 中。假如 prerequisites 中如果有一个以上的文件比 target 文件要新的话，就会重新生成该 target。</p>
<p>有了这些，我们就可以书写使用以上项目的 Makefile 了。</p>
<p><a href="lab/01/./multi-files/Makefile">Makefile</a></p>
<pre><code class="language-makefile">main: hello.o functions.o
	cc -o main hello.o functions.o

hello.o: hello.c functions.h
	cc -c hello.c

functions.o: functions.c functions.h
	cc -c functions.c

clean:
	rm main hello.o functions.o
</code></pre>
<p>需要注意，command 行需要以一个 Tab 为开始。</p>
<p>make 会比较 targets 和 prerequisites 的修改日期，如果 prerequisites 的日期比 targets 文件的日期更新，或者 target 不存在的话，make 就会执行后续定义的命令。</p>
<p>上述 Makefile 中，clean 只是一个动作名字，其冒号后什么也没有，那么 make 就不会自动去找它的依赖项，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 <code>make</code> 命令后显式指出这个 label 的名字。</p>
<p>比如，根据上述的 Makefile 执行 <code>make clean</code>，就会删除掉构建过程中产生的目标文件以及最后生成的可执行文件，还予用户一份清净。</p>
<blockquote>
<p>更多关于 Makefile 的介绍，可以移步 <a href="https://seisman.github.io/how-to-write-makefile/introduction.html">跟我一起写 Makefile（重制版） - 介绍</a>。关于详情可以移步 <a href="https://github.com/seisman/how-to-write-makefile">跟我一起写 Makefile（重制版）在 GitHub 上的仓库</a>。</p>
</blockquote>
<h3 id="5-构建管理工具cmake"><a class="header" href="#5-构建管理工具cmake">5. 构建管理工具：CMake</a></h3>
<p>亦可使用 CMake 这一款构建管理工具。CMake 会生成用于指定构建工具（比如上文中使用的 GNU make）的脚本。通过编写 <code>CMakeLists.txt</code> 文件，可以制定项目的构建方式，并通过 CMake 生成跨平台的构建脚本。</p>
<p>首先，需要安装 CMake 程序，并将 <code>cmake</code> 命令行工具添加入 PATH 环境变量。可以从包管理器安装 CMake，比如 <code>sudo apt install cmake</code>。</p>
<p>之后，编写 <a href="lab/01/./multi-files/CMakeLists.txt">CMakeLists.txt</a>：</p>
<pre><code class="language-cmake"># 要求最低的 CMake 版本
cmake_minimum_required(VERSION 3.1)

# 项目名称
project(hello)

# 生成可执行程序的目标
add_executable(main hello.c functions.h functions.c)
</code></pre>
<p>然后，需要新建一个目录，用来存放构建过程产生的文件。比如，可以在当前文件夹下新建一个 <code>build</code> 目录。将构建目录与源代码分开是个良好的习惯。</p>
<p>进入该目录后，调用 CMake，并将 <code>CMakeLists.txt</code> 所在的目录传递给 <code>cmake</code>。之后，CMake 将进行构建文件的生成。在 Ubuntu 下，默认会生成针对 GNU make 的 Makefile。完成生成后，我们在构建目录下执行 <code>make</code> 即可开始构建。</p>
<pre><code class="language-console">$ mkdir build
$ cd build
$ cmake ..
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/henry/multi-files/build
$ make
Scanning dependencies of target main
[ 33%] Building C object CMakeFiles/main.dir/hello.c.o
[ 66%] Building C object CMakeFiles/main.dir/functions.c.o
[100%] Linking C executable main
[100%] Built target main
$ ./main
Welcome, Henry.
The result of f(5) is 10.
The result of f(6) is 12.
The result of f(7) is 14.
</code></pre>
<p>更多关于 CMake 的介绍：</p>
<ul>
<li><a href="https://llvm.org/docs/CMakePrimer.html">https://llvm.org/docs/CMakePrimer.html</a></li>
</ul>
<h3 id="6-程序的定时启动"><a class="header" href="#6-程序的定时启动">6. 程序的定时启动</a></h3>
<p>Linux 上的 <code>cron</code> 守护进程能够在特定时间运行若干任务。使用正确的语法将任务添加进 <code>crontab</code> 文件即能够使 <code>cron</code> 自动运行这些任务。</p>
<p>计划任务通常为了被用来执行定期备份、系统维护以及其他重复性的操作。</p>
<p>使用 <code>crontab -e</code> 将开启当前用户的 <code>crontab</code> 文件。该文件中的命令将以当前用户的权限执行。</p>
<p>如果需要以系统权限执行任务，则使用 <code>sudo crontab -e</code> 打开 root 用户的 <code>crontab</code> 文件。</p>
<p>执行命令后，会提示选择一个编辑器，这里可以选择 GNU Nano 或者 vim。GNU nano 比较易于使用；vim 的使用方式类似 vi。</p>
<blockquote>
<p>如果想要修改使用的编辑器，可以退出后，在 bash 中设置一个临时环境变量 <code>EDITOR</code>，比如：</p>
<pre><code class="language-console">$ export EDITOR=vim
</code></pre>
</blockquote>
<p>每行以下面的格式声明一个计划任务：</p>
<pre><code>[minute] [hour] [day of month] [month] [day of week] [command]
</code></pre>
<p>在对应的位置使用 <code>*</code> 以匹配任意值。</p>
<p>比如，下面这个任务将在每天凌晨 0:30 执行：</p>
<pre><code>29 0 * * * /usr/bin/example
</code></pre>
<p>可以使用逗号 <code>,</code> 匹配多个值。下面的这个任务每 15 分钟执行一次。</p>
<pre><code>0,14,29,44 * * * * /usr/bin/example2
</code></pre>
<p>使用连字符 <code>-</code> 指定一个区间。下面的任务每天中午执行，但只限于每年的上半年：</p>
<pre><code>0 11 * 1-6 * /usr/bin/example3
</code></pre>
<blockquote>
<p>根据 GNU Nano 下方的提示，<code>^O</code> 以保存文件，即，按 <kbd>Ctrl</kbd> + <kbd>O</kbd> 保存文件，再按 Enter 确认保存的文件名。使用 <kbd>Ctrl</kbd> + <kbd>X</kbd> 可以退出 Nano。</p>
</blockquote>
<p>保存后，可以看到 <code>crontab: installing new crontab</code> 的信息，这表明成功安装了新的 <code>crontab</code> 文件。</p>
<blockquote>
<p>除此之外，也可以使用 <code>at</code> 程序来实现单次的计划任务。</p>
</blockquote>
<p>参考链接：</p>
<ul>
<li><a href="https://www.howtogeek.com/101288/how-to-schedule-tasks-on-linux-an-introduction-to-crontab-files/">https://www.howtogeek.com/101288/how-to-schedule-tasks-on-linux-an-introduction-to-crontab-files/</a></li>
<li><a href="https://linuxhint.com/schedule_linux_task/">https://linuxhint.com/schedule_linux_task/</a></li>
<li><a href="https://www.simplified.guide/linux/automatically-run-program-on-startup">https://www.simplified.guide/linux/automatically-run-program-on-startup</a></li>
<li><a href="https://askubuntu.com/questions/735935/running-command-at-startup-on-crontab">https://askubuntu.com/questions/735935/running-command-at-startup-on-crontab</a></li>
</ul>
<h2 id="四实验心得"><a class="header" href="#四实验心得">四、实验心得</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
