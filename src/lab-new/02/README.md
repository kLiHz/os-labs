# 实验二: 添加内核模块

## 实验目的

1. 掌握内核模块基本编程技术
2. 向内核中添加一个内核模块, 打印进程控制块信息, 编译模块
3. 加载、卸载模块

> 备注: 此模块要求返回当前运行进程 (CURRENT) 或者始祖进程 (init_task) 的进程控制块中的至少 30 项信息, 用中文标记含义. 此条备注不放入实验报告.

## 实验原理

内核模块 (kernel module) 是可以根据需要而被加载到内核中, 或从内核中卸载的代码. 这样便可以在运行过程中扩展内核的功能, 而无需重新引导系统.

举个例子, 设备驱动就是一种模块, 它让内核能够访问到连接到系统的硬件.

如果没有内核模块, 则不得不构建一个宏大的内核, 所有的新功能也都只能直接添加到内核镜像中.
除了内核将会非常巨大之外, 另一件麻烦事就是, 当每次想要添加新功能时, 都需要重新构建内核并重新引导系统.


1. 模块是 Linux 精心设计的一种机制, 可以用来动态增加内核的功能, 模块在内核空间运行. 
2. Linux模块可以在内核启动过程中加载, 这称为静态加载. 也可以在内核运行的过程中随时加载, 这称为动态加载. 
3. Linux中的大多数设备驱动程序或文件系统都被编译成模块, 因为它们数目繁多, 体积庞大, 不适合直接编译在内核中. 而通过模块机制, 在需要使用它们的时候, 在临时加载, 是最合适不过的. 

### Linux 内核模块软件包

在 Linux 发行版在一个软件包中提供了 `modprobe`, `insmod` 和 `depmod` 命令.

可以通过以下命令, 通过包管理器, 确保安装了所需的软件包 (构建工具和 `kmod`):

Ubuntu/Debian:

```
sudo apt-get install build-essential kmod
```

Arch Linux:

```
sudo pacman -S gcc kmod
```

### Linux 内核头文件

在开始构建之前, 需要确保安装了所使用内核对应的头文件.

### 最简的内核模块示例

首先建立一个测试目录, 如 `~/dev/kernel/hello1/`.

并在目录下新建一个 C 程序源文件, 如 `hello1.c`.

其中至少包含两个函数:

- `init_module()`: 模块加载的时候调用;
- `cleanup_module()`: 模块被卸载前调用.

```cpp
// hello1.c

{{#include assets/hello1/hello1.c}}
```

之后建立一个 `Makefile` 用于构建.

内核使用 `kbuild` 构建系统配置编译, `kbuild` 构建系统可用于编译自定义的内核模块.

编译过程首先会到内核源码目录下, 读取顶层的 `Makefile` 文件, 然后再编译模块源码, 连接生成的内核模块后缀为 `.ko`.

内核 Makefile 提供的 obj-m 表示对象文件 (object files) 编译成可加载的内核模块.

`hello-1.c` 的 `Makefile` 文件 `obj-m += hello-1.o` 表明有一个模块要从目标文件 `hello-1.o` 建立, `kbuild` 从该目标文件建立内核模块 `hello-1.ko`.

```
{{#include assets/hello1/Makefile}}
```






## 实验程序

### 向内核中添加一个内核模块, 打印进程控制块信息, 编译模块

hello.c

Makefile


### 返回当前运行进程 (current) 或始祖进程 (init_task) 的进程控制块中的至少 30 项信息

 

## 实验截图及结果分析

### 向内核中添加一个内核模块, 打印进程控制块信息, 编译模块

 

### 加载, 卸载模块

 

### 返回当前运行进程 (current) 或始祖进程 (init_task) 的进程控制块中的至少 30 项信息

 

## 实验心得

 
## 参考资料

[sysprog21/lkmpg: The Linux Kernel Module Programming Guide](https://github.com/sysprog21/lkmpg)
